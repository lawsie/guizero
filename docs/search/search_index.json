{
    "docs": [
        {
            "location": "/about/",
            "text": "About\n\n\nWhat is guizero?\n\n\n\n\nIt is a Python 3 library for creating simple GUIs\n\n\nIt is a wrapper for the standard Tkinter library (included by default when Python is installed)\n\n\n\n\nAims\n\n\nThe aim of guizero is to make the process of creating simple GUIs quick, accessible and understandable for children.\n\n\n\n\nWorks with standard Python Tkinter GUI library (and no need to install other libraries)\n\n\nAbstracts away details children find difficult to understand (such as Tkinter StringVar() objects)\n\n\nAccessible widget naming system to help children to build up a mental model\n\n\nFlexible enough to be used for projects up to A-Level standard, yet accessible to primary school children\n\n\nComprehensive and accessible documentation with examples\n\n\nGenerates helpful additional error messages\n\n\n\n\nVersion\n\n\nguizero is currently \nversion 0.5.0\n\n\nThere may be bugs and features may change and be updated.",
            "title": "About"
        },
        {
            "location": "/about/#about",
            "text": "",
            "title": "About"
        },
        {
            "location": "/about/#what-is-guizero",
            "text": "It is a Python 3 library for creating simple GUIs  It is a wrapper for the standard Tkinter library (included by default when Python is installed)",
            "title": "What is guizero?"
        },
        {
            "location": "/about/#aims",
            "text": "The aim of guizero is to make the process of creating simple GUIs quick, accessible and understandable for children.   Works with standard Python Tkinter GUI library (and no need to install other libraries)  Abstracts away details children find difficult to understand (such as Tkinter StringVar() objects)  Accessible widget naming system to help children to build up a mental model  Flexible enough to be used for projects up to A-Level standard, yet accessible to primary school children  Comprehensive and accessible documentation with examples  Generates helpful additional error messages",
            "title": "Aims"
        },
        {
            "location": "/about/#version",
            "text": "guizero is currently  version 0.5.0  There may be bugs and features may change and be updated.",
            "title": "Version"
        },
        {
            "location": "/",
            "text": "Installation\n\n\nguizero is designed to allow children to quickly and easily create GUIs for their programs.\n\n\nIf you can download and unzip a file, you can \ninstall guizero\n - \nno special permissions or administrator rights are required\n.\n\n\nIf you have administrator rights and are connected to the internet, you can use \npip to quickly install guizero\n.\n\n\nguizero only requires \ntkinter\n to be installed, which is included with a standard Python installation on all platforms except Linux.\n\n\nEasy installation\n\n\n\n\n\n\nGo to the \nGithub repo\n for guizero\n\n\n\n\n\n\nClick the green \"Clone or download\" button and then \"Download ZIP\"\n\n\n\n\n\n\n\n\nUnzip the file\n\n\n\n\n\n\nOpen the \nguizero-master\n folder, then copy the \nguizero\n folder and paste it into your home directory\n\n\n\n\n\n\n\n\nThat's it! When you write your guizero code, make sure you save it into your home directory.\n\n\n\n\n\n\nInstall using pip\n\n\nWindows\n\n\n\n\nMake sure you have \npip\n installed.\n\n\nOpen a command prompt\n\n\nType \npip install guizero\n and press Enter\n\n\n\n\nRaspberry Pi\n\n\n\n\nOpen a terminal window\n\n\nType \nsudo pip3 install guizero\n and press Enter\n\n\n\n\nMac OS\n\n\n\n\n\n\nOpen a terminal (you can search for it in the Launch Pad)\n\n\n\n\n\n\n\n\nType \nsudo pip3 install guizero\n\n\n\n\n\n\n\n\nLinux\n\n\n\n\nOpen a terminal\n\n\nInstall \ntkinter\n using your distribution's package manager, e.g. \nsudo apt install python3-tk\n\n\nInstall guizero using pip by typing \npip3 install guizero\n or \nsudo pip3 install guizero\n if you dont have superuser rights",
            "title": "Installation"
        },
        {
            "location": "/#installation",
            "text": "guizero is designed to allow children to quickly and easily create GUIs for their programs.  If you can download and unzip a file, you can  install guizero  -  no special permissions or administrator rights are required .  If you have administrator rights and are connected to the internet, you can use  pip to quickly install guizero .  guizero only requires  tkinter  to be installed, which is included with a standard Python installation on all platforms except Linux.",
            "title": "Installation"
        },
        {
            "location": "/#easy-installation",
            "text": "Go to the  Github repo  for guizero    Click the green \"Clone or download\" button and then \"Download ZIP\"     Unzip the file    Open the  guizero-master  folder, then copy the  guizero  folder and paste it into your home directory     That's it! When you write your guizero code, make sure you save it into your home directory.",
            "title": "Easy installation"
        },
        {
            "location": "/#install-using-pip",
            "text": "",
            "title": "Install using pip"
        },
        {
            "location": "/#windows",
            "text": "Make sure you have  pip  installed.  Open a command prompt  Type  pip install guizero  and press Enter",
            "title": "Windows"
        },
        {
            "location": "/#raspberry-pi",
            "text": "Open a terminal window  Type  sudo pip3 install guizero  and press Enter",
            "title": "Raspberry Pi"
        },
        {
            "location": "/#mac-os",
            "text": "Open a terminal (you can search for it in the Launch Pad)     Type  sudo pip3 install guizero",
            "title": "Mac OS"
        },
        {
            "location": "/#linux",
            "text": "Open a terminal  Install  tkinter  using your distribution's package manager, e.g.  sudo apt install python3-tk  Install guizero using pip by typing  pip3 install guizero  or  sudo pip3 install guizero  if you dont have superuser rights",
            "title": "Linux"
        },
        {
            "location": "/start/",
            "text": "Getting Started\n\n\nAt the start of every guizero program, choose the widgets you need from the guizero library and import them:\n\n\nfrom guizero import App, PushButton, Slider\n\n\n\n\nYou only need to import each widget once, and then you can use it in your program as many times as you like.\n\n\nHello World\n\n\nAll guizero projects begin with a main window which is called an \nApp\n. At the end of every guizero program you must tell the program to display the app you have just created.\n\n\nLet's create an app window with the title \"Hello world\":\n\n\nfrom guizero import App\napp = App(title=\"Hello world\")\napp.display()\n\n\n\n\nSave and run the code - you've created your first guizero app!\n\n\nAdding widgets\n\n\nWidgets are the things which appear on the GUI, such as text boxes, buttons, sliders and even plain old pieces of text.\n\n\nAll widgets\n go between the line of code to create the \nApp\n and the \napp.display()\n line.\n\n\nfrom guizero import App, Text\napp = App(title=\"Hello world\")\nmessage = Text(app, text=\"Welcome to the Hello world app!\")\napp.display()\n\n\n\n\n\n\nLet\u2019s look at the \nText\n widget code in a bit more detail:\n\n\nmessage = Text(app, text=\"Welcome to the Hello world app!\")\n\n\n\n\n\n\nmessage =\n - The \nText\n object has a name, just like any variable\n\n\nText\n - an \nobject\n which creates a piece of text on the screen\n\n\napp\n \u2013 This tells the \nText\n where it will live. Most of the time your widgets will live directly inside the app.\n\n\ntext=\"Welcome to the Hello world app!\"\n - The text to display\n\n\n\n\nAnd that's it! Now have a look on the documentation pages for the individual widgets to find out more about how to use them.",
            "title": "Getting started"
        },
        {
            "location": "/start/#getting-started",
            "text": "At the start of every guizero program, choose the widgets you need from the guizero library and import them:  from guizero import App, PushButton, Slider  You only need to import each widget once, and then you can use it in your program as many times as you like.",
            "title": "Getting Started"
        },
        {
            "location": "/start/#hello-world",
            "text": "All guizero projects begin with a main window which is called an  App . At the end of every guizero program you must tell the program to display the app you have just created.  Let's create an app window with the title \"Hello world\":  from guizero import App\napp = App(title=\"Hello world\")\napp.display()  Save and run the code - you've created your first guizero app!",
            "title": "Hello World"
        },
        {
            "location": "/start/#adding-widgets",
            "text": "Widgets are the things which appear on the GUI, such as text boxes, buttons, sliders and even plain old pieces of text.  All widgets  go between the line of code to create the  App  and the  app.display()  line.  from guizero import App, Text\napp = App(title=\"Hello world\")\nmessage = Text(app, text=\"Welcome to the Hello world app!\")\napp.display()   Let\u2019s look at the  Text  widget code in a bit more detail:  message = Text(app, text=\"Welcome to the Hello world app!\")   message =  - The  Text  object has a name, just like any variable  Text  - an  object  which creates a piece of text on the screen  app  \u2013 This tells the  Text  where it will live. Most of the time your widgets will live directly inside the app.  text=\"Welcome to the Hello world app!\"  - The text to display   And that's it! Now have a look on the documentation pages for the individual widgets to find out more about how to use them.",
            "title": "Adding widgets"
        },
        {
            "location": "/commands/",
            "text": "Commands\n\n\nWidgets in guizero can be given a \ncommand\n when created, which can be used to call a function when the widget is used.\n\n\nBy using commands you can make your GUI change and take actions when the user uses it e.g. clicking a button, selecting an option, typing a message. \n\n\nExample\n\n\nCreate an application which puts \nhello world\n on the GUI when a button is pressed:\n\n\nfrom guizero import App, Text, PushButton\n\ndef say_hello():\n    text.value = \"hello world\"\n\napp = App()\ntext = Text(app)\nbutton = PushButton(app, command=say_hello)\napp.display()",
            "title": "Commands"
        },
        {
            "location": "/commands/#commands",
            "text": "Widgets in guizero can be given a  command  when created, which can be used to call a function when the widget is used.  By using commands you can make your GUI change and take actions when the user uses it e.g. clicking a button, selecting an option, typing a message.",
            "title": "Commands"
        },
        {
            "location": "/commands/#example",
            "text": "Create an application which puts  hello world  on the GUI when a button is pressed:  from guizero import App, Text, PushButton\n\ndef say_hello():\n    text.value = \"hello world\"\n\napp = App()\ntext = Text(app)\nbutton = PushButton(app, command=say_hello)\napp.display()",
            "title": "Example"
        },
        {
            "location": "/multiple_windows/",
            "text": "Multiple Windows\n\n\nA guizero application should only have have 1 \nApp\n object, this is the main window and controller of your program.\n\n\nIf you want to create a 2nd (or 3rd, 4th, 5th) window, your program should use a \nWindow\n object.\n\n\nA 2nd Window\n\n\nCreating a 2nd Window is easy and just like creating a widget you need to pass it the App:\n\n\nfrom guizero import App, Window\n\napp = App(title = \"Main window\")\nwindow = Window(app, title = \"2nd window\")\n\napp.display\n\n\n\n\n\nAdding widgets to the 2nd window is the same as adding them to an app, by passing the same of the window:\n\n\nfrom guizero import App, Window, Text\n\napp = App(title = \"Main window\")\nwindow = Window(app, title = \"2nd window\")\ntext = Text(window, text=\"text\")\n\napp.display\n\n\n\n\n\nOpening and closing windows\n\n\nWhen a \nWindow\n object is created it is immediately displayed on the screen, you can control it using the \nshow()\n and \nhide()\n methods.\n\n\nTo make a window which is shown when a button on the \nApp\n is clicked and closed when a button is clicked on the \nWindow\n.\n\n\nfrom guizero import App, Window\n\ndef open_window():\n    window.show()\n\ndef close_window():\n    window.hide()\n\napp = App(title = \"Main window\")\n\nwindow = Window(app, title = \"2nd window\")\nwindow.hide()\n\nopen_button = PushButton(app, text = \"Open\", command = open_window)\nclose_button = PushButton(window, text = \"Close\", command = close_window)\n\napp.display\n\n\n\n\nModal windows\n\n\nWhen a window is opened using \nshow()\n it is opening side by side with the main window, and both windows can be used at the same time \n\n\nTo open a \"modal\" window which prevents the other windows in the applcation being used until it is closed you can pass \nTrue\n to the optional wait parameter of \nshow\n - \nshow(wait = True)\n.\n\n\nThis will force all other windows to wait until this window is closed before they can be used.\n\n\ndef open_window():\n    window.show(wait = True)",
            "title": "Multiple windows"
        },
        {
            "location": "/multiple_windows/#multiple-windows",
            "text": "A guizero application should only have have 1  App  object, this is the main window and controller of your program.  If you want to create a 2nd (or 3rd, 4th, 5th) window, your program should use a  Window  object.",
            "title": "Multiple Windows"
        },
        {
            "location": "/multiple_windows/#a-2nd-window",
            "text": "Creating a 2nd Window is easy and just like creating a widget you need to pass it the App:  from guizero import App, Window\n\napp = App(title = \"Main window\")\nwindow = Window(app, title = \"2nd window\")\n\napp.display  Adding widgets to the 2nd window is the same as adding them to an app, by passing the same of the window:  from guizero import App, Window, Text\n\napp = App(title = \"Main window\")\nwindow = Window(app, title = \"2nd window\")\ntext = Text(window, text=\"text\")\n\napp.display",
            "title": "A 2nd Window"
        },
        {
            "location": "/multiple_windows/#opening-and-closing-windows",
            "text": "When a  Window  object is created it is immediately displayed on the screen, you can control it using the  show()  and  hide()  methods.  To make a window which is shown when a button on the  App  is clicked and closed when a button is clicked on the  Window .  from guizero import App, Window\n\ndef open_window():\n    window.show()\n\ndef close_window():\n    window.hide()\n\napp = App(title = \"Main window\")\n\nwindow = Window(app, title = \"2nd window\")\nwindow.hide()\n\nopen_button = PushButton(app, text = \"Open\", command = open_window)\nclose_button = PushButton(window, text = \"Close\", command = close_window)\n\napp.display",
            "title": "Opening and closing windows"
        },
        {
            "location": "/multiple_windows/#modal-windows",
            "text": "When a window is opened using  show()  it is opening side by side with the main window, and both windows can be used at the same time   To open a \"modal\" window which prevents the other windows in the applcation being used until it is closed you can pass  True  to the optional wait parameter of  show  -  show(wait = True) .  This will force all other windows to wait until this window is closed before they can be used.  def open_window():\n    window.show(wait = True)",
            "title": "Modal windows"
        },
        {
            "location": "/layout/",
            "text": "Layouts\n\n\nThe \nApp\n parameter \nlayout\n allows you to specify whether the widgets in your app are placed automatically (\nauto\n), or whether you wish to position them yourself on a grid (\ngrid\n). The default layout is \nauto\n.\n\n\nIf you choose the \ngrid\n layout, this means that when you create a widget (other than the \nApp\n itself) you will need to pass the widget an extra parameter called \ngrid\n which is a list containing \n[x,y]\n coordinates for where you want the widget to appear, like this:\n\n\ntext = Text(app, text=\"Hello world\", grid=[0,1])\n\n\n\n\nThere is no need to specify the width or height of the grid you want - it will expand depending on the coordinates you provide with each widget. However, grid cells containing no objects will have no height or width.\n\n\nUsing grid layout\n\n\nYou can lay components out in a grid and specify where they appear with grid layout.\n\n\n\n\nfrom guizero import App, PushButton\ndef do_nothing():\n    print(\"Nothing happened\")\n\napp = App(title=\"Keypad example\", width=100, height=90, layout=\"grid\")\nbutton1 = PushButton(app, command=do_nothing, text=\"1\", grid=[0,0])\nbutton2 = PushButton(app, command=do_nothing, text=\"2\", grid=[1,0])\nbutton3  = PushButton(app, command=do_nothing, text=\"3\", grid=[2,0])\nbutton4  = PushButton(app, command=do_nothing, text=\"4\", grid=[0,1])\nbutton5  = PushButton(app, command=do_nothing, text=\"5\", grid=[1,1])\nbutton6  = PushButton(app, command=do_nothing, text=\"6\", grid=[2,1])\napp.display()\n\n\n\n\nSpanning columns or rows\n\n\nYou can have a widget span multiple columns or rows by specifying those within the grid parameter. These are optional, but if specified both must be included using the format \n[x,y,xspan,yspan]\n.\n\n\nThe example below shows text widget located at 0,1 spanning two columns (x) and one row (y):\n\n\ntext = Text(app, text=\"Hello world\", grid=[0,1,2,1])\n\n\n\n\nThis can be used to include widgets of different sizes arranged alongside each other.\n\n\n\n\nAssuming you have four appropriate image files then the code to create this is shown below.\n\n\nfrom guizero import App, Picture\n\napp = App(title=\"guizero grid span example\", width=460, height=210, layout=\"grid\")\npicture1 = Picture(app, image=\"std1.gif\", grid=[0,0])\npicture2 = Picture(app, image=\"std2.gif\", grid=[1,0])\npicture3 = Picture(app, image=\"tall1.gif\", grid=[2,0,1,2])\npicture4 = Picture(app, image=\"wide1.gif\", grid=[0,1,2,1])\n\napp.display()",
            "title": "Layouts"
        },
        {
            "location": "/layout/#layouts",
            "text": "The  App  parameter  layout  allows you to specify whether the widgets in your app are placed automatically ( auto ), or whether you wish to position them yourself on a grid ( grid ). The default layout is  auto .  If you choose the  grid  layout, this means that when you create a widget (other than the  App  itself) you will need to pass the widget an extra parameter called  grid  which is a list containing  [x,y]  coordinates for where you want the widget to appear, like this:  text = Text(app, text=\"Hello world\", grid=[0,1])  There is no need to specify the width or height of the grid you want - it will expand depending on the coordinates you provide with each widget. However, grid cells containing no objects will have no height or width.  Using grid layout  You can lay components out in a grid and specify where they appear with grid layout.   from guizero import App, PushButton\ndef do_nothing():\n    print(\"Nothing happened\")\n\napp = App(title=\"Keypad example\", width=100, height=90, layout=\"grid\")\nbutton1 = PushButton(app, command=do_nothing, text=\"1\", grid=[0,0])\nbutton2 = PushButton(app, command=do_nothing, text=\"2\", grid=[1,0])\nbutton3  = PushButton(app, command=do_nothing, text=\"3\", grid=[2,0])\nbutton4  = PushButton(app, command=do_nothing, text=\"4\", grid=[0,1])\nbutton5  = PushButton(app, command=do_nothing, text=\"5\", grid=[1,1])\nbutton6  = PushButton(app, command=do_nothing, text=\"6\", grid=[2,1])\napp.display()  Spanning columns or rows  You can have a widget span multiple columns or rows by specifying those within the grid parameter. These are optional, but if specified both must be included using the format  [x,y,xspan,yspan] .  The example below shows text widget located at 0,1 spanning two columns (x) and one row (y):  text = Text(app, text=\"Hello world\", grid=[0,1,2,1])  This can be used to include widgets of different sizes arranged alongside each other.   Assuming you have four appropriate image files then the code to create this is shown below.  from guizero import App, Picture\n\napp = App(title=\"guizero grid span example\", width=460, height=210, layout=\"grid\")\npicture1 = Picture(app, image=\"std1.gif\", grid=[0,0])\npicture2 = Picture(app, image=\"std2.gif\", grid=[1,0])\npicture3 = Picture(app, image=\"tall1.gif\", grid=[2,0,1,2])\npicture4 = Picture(app, image=\"wide1.gif\", grid=[0,1,2,1])\n\napp.display()",
            "title": "Layouts"
        },
        {
            "location": "/alerts/",
            "text": "Alerts\n\n\nUsing alerts\n\n\nTo use the alerts you will need to import each one individually at the start of your program. For example:\n\n\nfrom guizero import warn, info\n\n\n\n\nPurpose\n\n\nThese functions pop up a box on the screen that displays a message. The functions available are:\n\n\n\n\nwarn(title, text)\n - popup box with a warning icon\n\n\ninfo(title, text)\n - popup box with an information icon\n\n\nerror(title, text)\n - popup box with an error icon\n\n\nyesno(title, text)\n - popup box with yes and no options. Pressing \nYes\n returns \nTrue\n and pressing \nNo\n returns \nFalse\n.\n\n\n\n\nAll pop up boxes use the native display, so they will look different depending on your operating system.\n\n\nExamples\n\n\nWarning box\n\n\nThis will pop up a warning box with the title \n\"Uh oh!\"\n and the message \n\"You are almost out of biscuits!\"\n.\n\n\nfrom guizero import App, warn\napp = App(title=\"Biscuit monitor\")\nwarn(\"Uh oh!\", \"You are almost out of biscuits!\")\napp.display()\n\n\n\n\nOn Windows, the box looks like this:\n\n\n\n\nThe \ninfo\n and \nerror\n boxes work in exactly the same way but will display different icons.\n\n\nYes/No box\n\n\nWhen this function is called it returns a \nboolean\n value.\n\n\n\n\nIf \nYes\n was pressed, return \nTrue\n\n\nIf \nNo\n was pressed, return \nFalse\n\n\n\n\nYou can store this value in a variable and test it:\n\n\nfrom guizero import App, yesno, info, error\napp = App(title=\"Snowman\")\nbuild_a_snowman = yesno(\"A question...\", \"Do you want to build a snowman?\")\nif build_a_snowman == True:\n    info(\"Snowman\", \"It doesn't have to be a snowman\")\nelse:\n    error(\"Snowman\", \"Okay bye...\")\napp.display()\n\n\n\n\nThis code will first display the yes/no box\n\n\n\n\nIf \nYes\n is pressed, an information box will be displayed:\n\n\n\n\nIf \nNo\n is pressed, an error box will be displayed\n\n\n\n\nExample: Using an alert as a callback\n\n\nYou can also use these functions in a \ncallback\n (when you have to provide a function for another widget to call). Here is an example with a \nPushButton\n which pops up an \ninfo\n box when it is pressed.\n\n\nfrom guizero import App, PushButton, info\napp = App()\nbutton = PushButton(app, command=info, args=[\"Info\", \"You pressed the button\"])\napp.display()\n\n\n\n\nThe arguments provided to the \nPushButton\n are:\n\n\n\n\nWhere the button should be created (within the \napp\n)\n\n\nThe name of the function to call when pressed (\ninfo\n)\n\n\nA list of the arguments to the function you are calling (values for the \ntitle\n and \nmessage\n arguments for the \ninfo\n function)\n\n\n\n\nExample: Do you really want to close?\n\n\nYou can use a \nyesno\n box to check whether someone really wants to exit your app. If they click yes, the app is closed, if not, nothing happens and they can continue with what they were doing.\n\n\nfrom guizero import App, Text, yesno\n\n# Ask the user if they really want to close the window\ndef do_this_on_close():\n    if yesno(\"Close\", \"Do you want to quit?\"):\n        app.destroy()\n\napp = App()\n\ntitle = Text(app, text=\"blank app\")\n\n# When the user tries to close the window, run the function do_this_on_close()\napp.on_close(do_this_on_close)\n\napp.display()",
            "title": "Alerts"
        },
        {
            "location": "/alerts/#alerts",
            "text": "",
            "title": "Alerts"
        },
        {
            "location": "/alerts/#using-alerts",
            "text": "To use the alerts you will need to import each one individually at the start of your program. For example:  from guizero import warn, info",
            "title": "Using alerts"
        },
        {
            "location": "/alerts/#purpose",
            "text": "These functions pop up a box on the screen that displays a message. The functions available are:   warn(title, text)  - popup box with a warning icon  info(title, text)  - popup box with an information icon  error(title, text)  - popup box with an error icon  yesno(title, text)  - popup box with yes and no options. Pressing  Yes  returns  True  and pressing  No  returns  False .   All pop up boxes use the native display, so they will look different depending on your operating system.",
            "title": "Purpose"
        },
        {
            "location": "/alerts/#examples",
            "text": "Warning box  This will pop up a warning box with the title  \"Uh oh!\"  and the message  \"You are almost out of biscuits!\" .  from guizero import App, warn\napp = App(title=\"Biscuit monitor\")\nwarn(\"Uh oh!\", \"You are almost out of biscuits!\")\napp.display()  On Windows, the box looks like this:   The  info  and  error  boxes work in exactly the same way but will display different icons.  Yes/No box  When this function is called it returns a  boolean  value.   If  Yes  was pressed, return  True  If  No  was pressed, return  False   You can store this value in a variable and test it:  from guizero import App, yesno, info, error\napp = App(title=\"Snowman\")\nbuild_a_snowman = yesno(\"A question...\", \"Do you want to build a snowman?\")\nif build_a_snowman == True:\n    info(\"Snowman\", \"It doesn't have to be a snowman\")\nelse:\n    error(\"Snowman\", \"Okay bye...\")\napp.display()  This code will first display the yes/no box   If  Yes  is pressed, an information box will be displayed:   If  No  is pressed, an error box will be displayed   Example: Using an alert as a callback  You can also use these functions in a  callback  (when you have to provide a function for another widget to call). Here is an example with a  PushButton  which pops up an  info  box when it is pressed.  from guizero import App, PushButton, info\napp = App()\nbutton = PushButton(app, command=info, args=[\"Info\", \"You pressed the button\"])\napp.display()  The arguments provided to the  PushButton  are:   Where the button should be created (within the  app )  The name of the function to call when pressed ( info )  A list of the arguments to the function you are calling (values for the  title  and  message  arguments for the  info  function)   Example: Do you really want to close?  You can use a  yesno  box to check whether someone really wants to exit your app. If they click yes, the app is closed, if not, nothing happens and they can continue with what they were doing.  from guizero import App, Text, yesno\n\n# Ask the user if they really want to close the window\ndef do_this_on_close():\n    if yesno(\"Close\", \"Do you want to quit?\"):\n        app.destroy()\n\napp = App()\n\ntitle = Text(app, text=\"blank app\")\n\n# When the user tries to close the window, run the function do_this_on_close()\napp.on_close(do_this_on_close)\n\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/size/",
            "text": "Sizes\n\n\nYou can set the \nwidth\n and \nheight\n of widgets in guizero.\n\n\nWidgets are sized by pixels or characters depending on the widget and what it contains.\n\n\nfrom guizero import App, PushButton, Slide\napp = App()\n\n# a PushButton's size is noted in characters\nbutton = PushButton(app)\nbutton.width = 30\nbutton.height = 5\n\n# a Slider's size is noted in pixels\nslider = Slider(app)\nslider.width = 300\nslider.height = 30  \n\n\n\n\n\n\n\n\n\n\nWidget\n\n\nCharacters or Pixels\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nBox\n\n\nPixels\n\n\nThe size only takes affect if the Box is empty, if the Box contains any widgets it will size to the widgets inside it\n\n\n\n\n\n\nButtonGroup\n\n\nCharacters\n\n\nThe height of a ButtonGroup must divide by the number of buttons in it\n\n\n\n\n\n\nCheckBox\n\n\nCharacters\n\n\n\n\n\n\n\n\nCombo\n\n\nCharacters\n\n\n\n\n\n\n\n\nPicture\n\n\nPixels\n\n\nThe image wont scale to the size of the Picture\n\n\n\n\n\n\nPushButton\n\n\nCharacters\n\n\nPushButton's are sized in Characters, unless they contain an icon in which case they are sized in Pixels\n\n\n\n\n\n\nSlider\n\n\nPixels\n\n\n\n\n\n\n\n\nText\n\n\nCharacters\n\n\n\n\n\n\n\n\nTextBox\n\n\nCharacters\n\n\nOnly a TextBox's width can be set\n\n\n\n\n\n\nWaffle\n\n\nPixels",
            "title": "Sizes"
        },
        {
            "location": "/size/#sizes",
            "text": "You can set the  width  and  height  of widgets in guizero.  Widgets are sized by pixels or characters depending on the widget and what it contains.  from guizero import App, PushButton, Slide\napp = App()\n\n# a PushButton's size is noted in characters\nbutton = PushButton(app)\nbutton.width = 30\nbutton.height = 5\n\n# a Slider's size is noted in pixels\nslider = Slider(app)\nslider.width = 300\nslider.height = 30       Widget  Characters or Pixels  Notes      Box  Pixels  The size only takes affect if the Box is empty, if the Box contains any widgets it will size to the widgets inside it    ButtonGroup  Characters  The height of a ButtonGroup must divide by the number of buttons in it    CheckBox  Characters     Combo  Characters     Picture  Pixels  The image wont scale to the size of the Picture    PushButton  Characters  PushButton's are sized in Characters, unless they contain an icon in which case they are sized in Pixels    Slider  Pixels     Text  Characters     TextBox  Characters  Only a TextBox's width can be set    Waffle  Pixels",
            "title": "Sizes"
        },
        {
            "location": "/colors/",
            "text": "Colors (or Colo\nu\nrs)\n\n\nYou can set colors in guizero using:\n\n\n\n\nthe name of the color - \nwhite\n\n\na #rgb hex value - \n#ffffff\n\n\na list of rgb values - \n(255,255,255)\n \n\n\n\n\nColors can be used as either starting parameters e.g. :\n\n\napp = App(bg = \"red\")\napp = App(bg = \"#ff0000\")\napp = App(bg = (255, 0, 0))\n\n\n\n\nor as properties e.g. :\n\n\ntext = Text(app, text = \"hi\")\ntext.text_color = \"green\"\ntext.text_color = \"#00ff00\"\ntext.text_color = (0, 255, 0)\n\n\n\n\nColor names\n\n\nColor names can be given as strings e.g.\n\n\n\n\nwhite\n\n\nblack\n\n\nred\n\n\ngreen\n\n\nblue\n\n\nyellow\n\n\n\n\nA complete list of color names is available at \nwiki.tcl.tk/37701\n\n\nrgb hex value\n\n\nA rgb color value must start with a \n#\n and 6 characters following, 2 each for the red, green and blue value in hex. Each value must be \n00\n - \nff\n e.g.\n\n\n\n\nwhite = \n#ffffff\n\n\nblack = \n#000000\n\n\nred = \n#ff0000\n\n\ngreen = \n#00ff00\n\n\nblue = \n#0000ff\n\n\nyellow = \n#ffff00\n\n\n\n\nYou can mix your own color by changing the red, green and blue values. \n\n\nThere is a RGB calculator application at \nhttps://www.w3schools.com/colors/colors_rgb.asp\n where you can create your own color and get the \n#rrggbb\n value.\n\n\nrgb list\n\n\nThe \n(red, green, blue)\n list color, must have 3 elements in the order red, green, blue with values 0 - 255 e.g.\n\n\n\n\nwhite = (255, 255, 255)\n\n\nblack = (0, 0, 0)\n\n\nred = (255, 0, 0)\n\n\ngreen = (0, 255, 0)\n\n\nblue = (0, 0, 255)\n\n\nyellow = (255, 255, 0)",
            "title": "Colors"
        },
        {
            "location": "/colors/#colors-or-colours",
            "text": "You can set colors in guizero using:   the name of the color -  white  a #rgb hex value -  #ffffff  a list of rgb values -  (255,255,255)     Colors can be used as either starting parameters e.g. :  app = App(bg = \"red\")\napp = App(bg = \"#ff0000\")\napp = App(bg = (255, 0, 0))  or as properties e.g. :  text = Text(app, text = \"hi\")\ntext.text_color = \"green\"\ntext.text_color = \"#00ff00\"\ntext.text_color = (0, 255, 0)",
            "title": "Colors (or Colours)"
        },
        {
            "location": "/colors/#color-names",
            "text": "Color names can be given as strings e.g.   white  black  red  green  blue  yellow   A complete list of color names is available at  wiki.tcl.tk/37701",
            "title": "Color names"
        },
        {
            "location": "/colors/#rgb-hex-value",
            "text": "A rgb color value must start with a  #  and 6 characters following, 2 each for the red, green and blue value in hex. Each value must be  00  -  ff  e.g.   white =  #ffffff  black =  #000000  red =  #ff0000  green =  #00ff00  blue =  #0000ff  yellow =  #ffff00   You can mix your own color by changing the red, green and blue values.   There is a RGB calculator application at  https://www.w3schools.com/colors/colors_rgb.asp  where you can create your own color and get the  #rrggbb  value.",
            "title": "rgb hex value"
        },
        {
            "location": "/colors/#rgb-list",
            "text": "The  (red, green, blue)  list color, must have 3 elements in the order red, green, blue with values 0 - 255 e.g.   white = (255, 255, 255)  black = (0, 0, 0)  red = (255, 0, 0)  green = (0, 255, 0)  blue = (0, 0, 255)  yellow = (255, 255, 0)",
            "title": "rgb list"
        },
        {
            "location": "/images/",
            "text": "Images\n\n\nWidgets such as \nPicture\n and \nPushButton\n allow you to use images in your GUI.\n\n\nfrom guizero import App, Picture\napp = App()\npicture = Picture(app, image=\"test.gif\")\napp.display()\n\n\n\n\nThe types of image (GIF, JPG, PNG, etc) supported depend on how you \ninstalled guizero\n and the setup of your computer.\n\n\nSupported files types\n\n\nAll systems support the \nGIF\n file type.\n\n\nWindows and Linux also support \nPNG\n files.\n\n\nIf you \ninstalled guizero\n using \npip\n it will also have installed \nPIL\n (Python Imaging Library) and you will be able use the majority of commonly used image types.\n\n\nguizero will tell you what file types are supported on your computer using the following code:\n\n\nfrom guizero import system_config\nprint(system_config.supported_image_types)\n\n\n\n\n\n\n\n\n\n\nOperating System\n\n\nPIL NOT available\n\n\nPIL available\n\n\n\n\n\n\n\n\n\n\nWindows\n\n\nGIF, PNG\n\n\nGIF, Animated GIF, BMP, ICO, PNG, JPG, TIF\n\n\n\n\n\n\nMacOS\n\n\nGIF\n\n\nGIF, Animated GIF, BMP, ICO, PNG, JPG, TIF\n\n\n\n\n\n\nLinux\n\n\nGIF, PNG\n\n\nGIF, Animated GIF, BMP, ICO, PNG, JPG, TIF\n\n\n\n\n\n\nRaspbian\n\n\nGIF, PNG\n\n\nGIF, Animated GIF, BMP, ICO, PNG, JPG, TIF\n\n\n\n\n\n\n\n\nResizing\n\n\nWhen the size of a widget is changed the image will be changed to fit the widget, if \nPIL\n is available the image will be scaled correctly, if not the image will be cropped.\n\n\nAnimated GIFs\n\n\nguizero supports displaying animated GIFs if \nPIL\n is installed, if not, the GIF will be displayed as a static image.",
            "title": "Images"
        },
        {
            "location": "/images/#images",
            "text": "Widgets such as  Picture  and  PushButton  allow you to use images in your GUI.  from guizero import App, Picture\napp = App()\npicture = Picture(app, image=\"test.gif\")\napp.display()  The types of image (GIF, JPG, PNG, etc) supported depend on how you  installed guizero  and the setup of your computer.",
            "title": "Images"
        },
        {
            "location": "/images/#supported-files-types",
            "text": "All systems support the  GIF  file type.  Windows and Linux also support  PNG  files.  If you  installed guizero  using  pip  it will also have installed  PIL  (Python Imaging Library) and you will be able use the majority of commonly used image types.  guizero will tell you what file types are supported on your computer using the following code:  from guizero import system_config\nprint(system_config.supported_image_types)     Operating System  PIL NOT available  PIL available      Windows  GIF, PNG  GIF, Animated GIF, BMP, ICO, PNG, JPG, TIF    MacOS  GIF  GIF, Animated GIF, BMP, ICO, PNG, JPG, TIF    Linux  GIF, PNG  GIF, Animated GIF, BMP, ICO, PNG, JPG, TIF    Raspbian  GIF, PNG  GIF, Animated GIF, BMP, ICO, PNG, JPG, TIF",
            "title": "Supported files types"
        },
        {
            "location": "/images/#resizing",
            "text": "When the size of a widget is changed the image will be changed to fit the widget, if  PIL  is available the image will be scaled correctly, if not the image will be cropped.",
            "title": "Resizing"
        },
        {
            "location": "/images/#animated-gifs",
            "text": "guizero supports displaying animated GIFs if  PIL  is installed, if not, the GIF will be displayed as a static image.",
            "title": "Animated GIFs"
        },
        {
            "location": "/blocking/",
            "text": "Loops and sleeping\n\n\nYou may be used to writing programs which contain loops or make use of the \nsleep()\n command, but find when you try to use these with guizero they cause your GUI to freeze. This is because guizero (in common with almost all GUIs) operates an \nevent driven\n model of programming which may be different to the one you are familiar with.\n\n\nYour first guizero program might look a bit like this:\n\n\nfrom guizero import App\napp = App(\"Hello world\")\napp.display()\n\n\n\n\nThe line of code \napp.display()\n doesn't just display the app - it enters an \ninfinite event loop\n which is watching and waiting for events to happen on the GUI. Events include things like the user clicking on a button, moving a slider, typing in a text box etc. No code written after this line will ever execute because the event loop is infinite.\n\n\nExample\n\n\nSuppose you want a counter on your GUI to start counting up by 1 every second. You might be tempted to write a program like this:\n\n\nfrom guizero import App, Text\nfrom time import sleep\n\napp = App(\"Hello world\")\ntext = Text(app, text=\"1\")\nwhile True:\n    text.value = int(text.value) + 1\n    sleep(1)\napp.display()\n\n\n\n\nIf you run this program, you'll see that this does not have the desired effect - your program crashes! This is because you have blocked the updating of your GUI in two ways:\n\n\n\n\n\n\nThe \nsleep()\n command - whilst your program is sleeping, the GUI will not update and you will not be able to click on anything.\n\n\n\n\n\n\nThe \nwhile\n loop - once you enter this loop, your GUI will never update ever again and will probably crash.\n\n\n\n\n\n\nSolution\n\n\nThis behaviour is not a bug within guizero or tkinter.\n\n\nYou must write GUI based programs in a different way to the one you may be used to. If you want to repeatedly perform an action you would do it like this:\n\n\n\n\n\n\nWrite a function which performs the desired action (in this example \ncounter()\n)\n\n\n\n\n\n\nSet a \ncallback\n to that function. You can either schedule the same callback to occur repeatedly after a given number of milliseconds (in this example \n1000\n), or you can schedule it only once.\n\n\n\n\n\n\nfrom guizero import App, Text\n\n# Action you would like to perform\ndef counter():\n    text.value = int(text.value) + 1\n\napp = App(\"Hello world\")\ntext = Text(app, text=\"1\")\ntext.repeat(1000, counter)  # Schedule call to counter() every 1000ms\napp.display()",
            "title": "Loops and sleeping"
        },
        {
            "location": "/blocking/#loops-and-sleeping",
            "text": "You may be used to writing programs which contain loops or make use of the  sleep()  command, but find when you try to use these with guizero they cause your GUI to freeze. This is because guizero (in common with almost all GUIs) operates an  event driven  model of programming which may be different to the one you are familiar with.  Your first guizero program might look a bit like this:  from guizero import App\napp = App(\"Hello world\")\napp.display()  The line of code  app.display()  doesn't just display the app - it enters an  infinite event loop  which is watching and waiting for events to happen on the GUI. Events include things like the user clicking on a button, moving a slider, typing in a text box etc. No code written after this line will ever execute because the event loop is infinite.",
            "title": "Loops and sleeping"
        },
        {
            "location": "/blocking/#example",
            "text": "Suppose you want a counter on your GUI to start counting up by 1 every second. You might be tempted to write a program like this:  from guizero import App, Text\nfrom time import sleep\n\napp = App(\"Hello world\")\ntext = Text(app, text=\"1\")\nwhile True:\n    text.value = int(text.value) + 1\n    sleep(1)\napp.display()  If you run this program, you'll see that this does not have the desired effect - your program crashes! This is because you have blocked the updating of your GUI in two ways:    The  sleep()  command - whilst your program is sleeping, the GUI will not update and you will not be able to click on anything.    The  while  loop - once you enter this loop, your GUI will never update ever again and will probably crash.",
            "title": "Example"
        },
        {
            "location": "/blocking/#solution",
            "text": "This behaviour is not a bug within guizero or tkinter.  You must write GUI based programs in a different way to the one you may be used to. If you want to repeatedly perform an action you would do it like this:    Write a function which performs the desired action (in this example  counter() )    Set a  callback  to that function. You can either schedule the same callback to occur repeatedly after a given number of milliseconds (in this example  1000 ), or you can schedule it only once.    from guizero import App, Text\n\n# Action you would like to perform\ndef counter():\n    text.value = int(text.value) + 1\n\napp = App(\"Hello world\")\ntext = Text(app, text=\"1\")\ntext.repeat(1000, counter)  # Schedule call to counter() every 1000ms\napp.display()",
            "title": "Solution"
        },
        {
            "location": "/events/",
            "text": "Events\n\n\nWarning - events are currently experimental, issues maybe experienced and the API may change.\n.\n\n\nCustom events can be added to guizero widgets to call functions when the user takes the following actions:\n\n\n\n\nwhen clicked - \nwhen_clicked\n\n\nwhen the left mouse button is pressed - \nwhen_left_button_pressed\n\n\nwhen the left mouse button is released - \nwhen_left_button_released\n\n\nwhen the right mouse button is pressed - \nwhen_right_button_pressed\n\n\nwhen the right mouse button is released - \nwhen_right_button_released\n\n\nwhen a key is pressed - \nwhen_key_pressed\n\n\nwhen a key is released - \nwhen_key_released\n\n\nwhen the mouse enters a widget - \nwhen_mouse_enters\n\n\nwhen the mouse leaves a widget - \nwhen_mouse_leaves\n\n\nwhen the mouse is dragged across a widget - \nwhen_mouse_dragged\n\n\n\n\nEvents are set by assigning them to a function:\n\n\ndef clicked():\n    print(\"clicked\")\n\nwidget.when_clicked = clicked\n\n\n\n\nEvent Data\n\n\nThe function which is called can also accept a parameter and will be passed data about the event which occured.\n\n\nThe event data returned has:\n\n\n\n\nwidget\n - the guizero widget which raised the event\n\n\ntk_event\n - the \ntkinter event object\n\n\nkey\n - the key which raised the event\n\n\nx\n - the mouse's x position relative to the widget when the event occured\n\n\ny\n - the mouse's y position relative to the widget when the event occured\n\n\ndisplay_x\n - the mouse's x position on the display when the event occured\n\n\ndisplay_y\n - the mouse's y position on the display when the event occured\n\n\n\n\ndef clicked(event_data):\n    print(\"widget clicked = \" + event_data.widget)\n    print(\"mouse position = \" + event_data.x + \".\" + event_data.y)\n\nwidget.when_clicked = clicked\n\n\n\n\nExample\n\n\nHighlight a text box widget by changing its background color (\nbg\n) when the mouse is hovering over it.\n\n\nfrom guizero import App, TextBox\n\ndef highlight():\n    text_box.bg = \"lightblue\"\n\ndef lowlight():\n    text_box.bg = \"white\"\n\napp = App()\ntext_box = TextBox(app)\n\n# when the mouse enters the textbox\ntext_box.when_mouse_enters = highlight\n# when the mouse leaves the textbox\ntext_box.when_mouse_leaves = lowlight\n\napp.display()",
            "title": "Events"
        },
        {
            "location": "/events/#events",
            "text": "Warning - events are currently experimental, issues maybe experienced and the API may change. .  Custom events can be added to guizero widgets to call functions when the user takes the following actions:   when clicked -  when_clicked  when the left mouse button is pressed -  when_left_button_pressed  when the left mouse button is released -  when_left_button_released  when the right mouse button is pressed -  when_right_button_pressed  when the right mouse button is released -  when_right_button_released  when a key is pressed -  when_key_pressed  when a key is released -  when_key_released  when the mouse enters a widget -  when_mouse_enters  when the mouse leaves a widget -  when_mouse_leaves  when the mouse is dragged across a widget -  when_mouse_dragged   Events are set by assigning them to a function:  def clicked():\n    print(\"clicked\")\n\nwidget.when_clicked = clicked",
            "title": "Events"
        },
        {
            "location": "/events/#event-data",
            "text": "The function which is called can also accept a parameter and will be passed data about the event which occured.  The event data returned has:   widget  - the guizero widget which raised the event  tk_event  - the  tkinter event object  key  - the key which raised the event  x  - the mouse's x position relative to the widget when the event occured  y  - the mouse's y position relative to the widget when the event occured  display_x  - the mouse's x position on the display when the event occured  display_y  - the mouse's y position on the display when the event occured   def clicked(event_data):\n    print(\"widget clicked = \" + event_data.widget)\n    print(\"mouse position = \" + event_data.x + \".\" + event_data.y)\n\nwidget.when_clicked = clicked",
            "title": "Event Data"
        },
        {
            "location": "/events/#example",
            "text": "Highlight a text box widget by changing its background color ( bg ) when the mouse is hovering over it.  from guizero import App, TextBox\n\ndef highlight():\n    text_box.bg = \"lightblue\"\n\ndef lowlight():\n    text_box.bg = \"white\"\n\napp = App()\ntext_box = TextBox(app)\n\n# when the mouse enters the textbox\ntext_box.when_mouse_enters = highlight\n# when the mouse leaves the textbox\ntext_box.when_mouse_leaves = lowlight\n\napp.display()",
            "title": "Example"
        },
        {
            "location": "/usingtk/",
            "text": "Using tkinter methods\n\n\nIf you are an advanced user, you can still make use of any tkinter method which is not implemented in guizero.\n\n\nEach guizero widget itself contains a tk widget - you can find out which by looking on the guizero documentation page for the widget. For example, a guizero \nTextBox\n contains a tkinter \nEntry\n object. You can always access the internal object using the syntax \n<object_name>.tk\n.\n\n\nUsing a tkinter method on a guizero object\n\n\nIn this example, we have guizero \nApp\n and \nTextBox\n widgets.\n\n\nfrom guizero import App, TextBox\napp = App()\nname = TextBox(app)\napp.display()\n\n\n\n\nYou want to make the text in the box appear red, but you discover that at the moment this isn't possible in guizero. So instead, you access the internal tk widget directly using \n<object_name>.tk\n and then you call the tkinter method:\n\n\nfrom guizero import App, TextBox\napp = App()\nname = TextBox(app, text=\"Laura\")\nname.tk.config(foreground=\"red\")    # config() is a tkinter method\napp.display()\n\n\n\n\nYou can combine the use of \nguizero\n and \ntkinter\n seamlessly in a program, taking advantage of the simplified syntax of guizero whilst still being able to access the full range of functionality in tkinter if you need it.",
            "title": "Using tkinter methods"
        },
        {
            "location": "/usingtk/#using-tkinter-methods",
            "text": "If you are an advanced user, you can still make use of any tkinter method which is not implemented in guizero.  Each guizero widget itself contains a tk widget - you can find out which by looking on the guizero documentation page for the widget. For example, a guizero  TextBox  contains a tkinter  Entry  object. You can always access the internal object using the syntax  <object_name>.tk .",
            "title": "Using tkinter methods"
        },
        {
            "location": "/usingtk/#using-a-tkinter-method-on-a-guizero-object",
            "text": "In this example, we have guizero  App  and  TextBox  widgets.  from guizero import App, TextBox\napp = App()\nname = TextBox(app)\napp.display()  You want to make the text in the box appear red, but you discover that at the moment this isn't possible in guizero. So instead, you access the internal tk widget directly using  <object_name>.tk  and then you call the tkinter method:  from guizero import App, TextBox\napp = App()\nname = TextBox(app, text=\"Laura\")\nname.tk.config(foreground=\"red\")    # config() is a tkinter method\napp.display()  You can combine the use of  guizero  and  tkinter  seamlessly in a program, taking advantage of the simplified syntax of guizero whilst still being able to access the full range of functionality in tkinter if you need it.",
            "title": "Using a tkinter method on a guizero object"
        },
        {
            "location": "/resources/",
            "text": "Examples and resources\n\n\n\n\n\n\nGetting started with GUIs\n - a beginners guide to guizero by the Raspberry Pi Foundation\n\n\n\n\n\n\nCat name generator\n - materials for a kids workshop, first run at the \nCotswold Jam\n\n\n\n\n\n\nName your pet\n - article on page 42 of \nHello World\n magazine issue 2.\n\n\n\n\n\n\nExample programs\n - some simple example programs\n\n\n\n\n\n\nIf you have created an educational resource using guizero, please share it with us by submitting a pull request to the \nexamples folder\n on GitHub",
            "title": "Examples and resources"
        },
        {
            "location": "/resources/#examples-and-resources",
            "text": "Getting started with GUIs  - a beginners guide to guizero by the Raspberry Pi Foundation    Cat name generator  - materials for a kids workshop, first run at the  Cotswold Jam    Name your pet  - article on page 42 of  Hello World  magazine issue 2.    Example programs  - some simple example programs    If you have created an educational resource using guizero, please share it with us by submitting a pull request to the  examples folder  on GitHub",
            "title": "Examples and resources"
        },
        {
            "location": "/app/",
            "text": "App\n\n\n(Contains a \ntkinter.Tk\n object)\n\n\n__init__(self, title=\"guizero\", width=500, height=500, layout=\"auto\", bgcolor=None, bg=None)\n\n\nWhat is it?\n\n\nThe \nApp\n object is the basis of all GUIs created using guizero. It is the main window which contains all of the other widgets.\n\n\n\n\nHow do I make one?\n\n\nCreate an \nApp\n object like this:\n\n\nfrom guizero import App\napp = App()\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create an \nApp\n object you can specify any of the following parameters, all of which are optional. Specify parameters in the brackets like this: \napp = App(bg=\"red\", height=200)\n\n\n\n\n\n\n\n\nParameter\n\n\nData type\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nNone\n\n\nNo\n\n\nThe background colour of the app window. Takes a \ncolor\n value.\n\n\n\n\n\n\nheight\n\n\nint\n\n\n500\n\n\nNo\n\n\nThe height of the window in pixels.\n\n\n\n\n\n\nlayout\n\n\nstring\n\n\n\"auto\"\n\n\nNo\n\n\nWhether widgets pack themselves (\n\"auto\"\n) or you specify their position on a grid (\n\"grid\"\n)\n\n\n\n\n\n\ntitle\n\n\nstring\n\n\n\"guizero\"\n\n\nNo\n\n\nThe title displayed in the bar at the top of the window.\n\n\n\n\n\n\nwidth\n\n\nint\n\n\n500\n\n\nNo\n\n\nThe width of the window in pixels.\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the App should be visible.\n\n\n\n\n\n\nbgcolor\n\n\nstring\n\n\nNone\n\n\nNo\n\n\nReplaced by \nbg\n parameter\n\n\n\n\n\n\n\n\nParameters in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nMethods\n\n\nYou can call the following methods on an \nApp\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisplay()\n\n\n-\n\n\n-\n\n\nDisplays the app on the screen. You \nMUST\n call this method at the end of your program to display the app on the screen.\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the app window from view.\n\n\n\n\n\n\non_close(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCalls the given function when the user tries to close the window.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the app window if it was previously hidden\n\n\n\n\n\n\nset_title(title)\n\n\ntitle (string)\n\n\n-\n\n\nReplaced by \ntitle\n property\n\n\n\n\n\n\nbgcolor\n\n\nbgcolor (string)\n\n\n-\n\n\nReplaced by \nbg\n property\n\n\n\n\n\n\n\n\nParameters in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the window\n\n\n\n\n\n\nheight\n\n\nint\n\n\nThe height of the window\n\n\n\n\n\n\nlayout\n\n\nstring\n\n\nThe layout being used by the App (\n\"auto\"\n) or (\n\"grid\"\n)\n\n\n\n\n\n\ntitle\n\n\nstring\n\n\nThe title of the window\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf the app is visible\n\n\n\n\n\n\nwidth\n\n\nint\n\n\nThe width of the window\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nApp\n object is called \napp\n you would write \napp.title\n.\n\n\nYou can \nset\n the property (for example \napp.title = \"Hello world\"\n) or \nget\n the value of the property to use (for example \nprint(app.title)\n).\n\n\nExamples\n\n\nCreating an App object\n\n\nCreate an \nApp\n object by calling the \nApp()\n constructor. You should give the object a name so you can refer to it later - in this case we have called it \napp\n. It is best to keep the name you give to your \nApp\n object quite short, as you will have to use it to tell other widgets where they should be stored.\n\n\nAt the end of the program you \nMUST\n tell the app object to begin the display loop.\n\n\nfrom guizero import App\napp = App(title=\"My app\", height=300, width=200)\napp.display()\n\n\n\n\nChanging the title\n\n\nYou can change the title of the app object once it has been created like this:\n\n\nfrom guizero import App\napp = App(title=\"My app\", height=300, width=200)\napp.title = \"A different title\"\napp.display()\n\n\n\n\nThis will display the app with the updated title:",
            "title": "App"
        },
        {
            "location": "/app/#app",
            "text": "(Contains a  tkinter.Tk  object)  __init__(self, title=\"guizero\", width=500, height=500, layout=\"auto\", bgcolor=None, bg=None)",
            "title": "App"
        },
        {
            "location": "/app/#what-is-it",
            "text": "The  App  object is the basis of all GUIs created using guizero. It is the main window which contains all of the other widgets.",
            "title": "What is it?"
        },
        {
            "location": "/app/#how-do-i-make-one",
            "text": "Create an  App  object like this:  from guizero import App\napp = App()\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/app/#starting-parameters",
            "text": "When you create an  App  object you can specify any of the following parameters, all of which are optional. Specify parameters in the brackets like this:  app = App(bg=\"red\", height=200)     Parameter  Data type  Default  Compulsory  Description      bg  color  None  No  The background colour of the app window. Takes a  color  value.    height  int  500  No  The height of the window in pixels.    layout  string  \"auto\"  No  Whether widgets pack themselves ( \"auto\" ) or you specify their position on a grid ( \"grid\" )    title  string  \"guizero\"  No  The title displayed in the bar at the top of the window.    width  int  500  No  The width of the window in pixels.    visible  boolean  True  No  If the App should be visible.    bgcolor  string  None  No  Replaced by  bg  parameter     Parameters in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Starting parameters"
        },
        {
            "location": "/app/#methods",
            "text": "You can call the following methods on an  App  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    display()  -  -  Displays the app on the screen. You  MUST  call this method at the end of your program to display the app on the screen.    focus()  -  -  Gives focus to the widget    hide()  -  -  Hides the app window from view.    on_close(command)  command (function name)  -  Calls the given function when the user tries to close the window.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the app window if it was previously hidden    set_title(title)  title (string)  -  Replaced by  title  property    bgcolor  bgcolor (string)  -  Replaced by  bg  property     Parameters in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/app/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      bg  color  The background colour of the window    height  int  The height of the window    layout  string  The layout being used by the App ( \"auto\" ) or ( \"grid\" )    title  string  The title of the window    visible  boolean  If the app is visible    width  int  The width of the window     Refer to a property as  <name of widget>.property . For example, if your  App  object is called  app  you would write  app.title .  You can  set  the property (for example  app.title = \"Hello world\" ) or  get  the value of the property to use (for example  print(app.title) ).",
            "title": "Properties"
        },
        {
            "location": "/app/#examples",
            "text": "Creating an App object  Create an  App  object by calling the  App()  constructor. You should give the object a name so you can refer to it later - in this case we have called it  app . It is best to keep the name you give to your  App  object quite short, as you will have to use it to tell other widgets where they should be stored.  At the end of the program you  MUST  tell the app object to begin the display loop.  from guizero import App\napp = App(title=\"My app\", height=300, width=200)\napp.display()  Changing the title  You can change the title of the app object once it has been created like this:  from guizero import App\napp = App(title=\"My app\", height=300, width=200)\napp.title = \"A different title\"\napp.display()  This will display the app with the updated title:",
            "title": "Examples"
        },
        {
            "location": "/box/",
            "text": "Box\n\n\n(Contains a \ntkinter.Frame\n object)\n\n\n__init__(self, master, layout=\"auto\", grid=None, align=None)\n\n\nWhat is it?\n\n\nThe \nBox\n object is an invisible container which can contain other widgets. It is the only object other than \nApp\n which can act as the \nmaster\n for other objects and can have its own layout manager.\n\n\nYou can use the \nBox\n object to group other objects within your GUI.\n\n\nHow do I make one?\n\n\nCreate a \nBox\n object like this:\n\n\nfrom guizero import App, Box\napp = App()\nbox = Box(app)\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nBox\n object you \nmust\n specify a master, and you can specify any of the optional parameters. Specify parameters in the brackets like this: \nbox = Box(app, layout=\"grid\")\n\n\n\n\n\n\n\n\nParameter\n\n\nData type\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp\n\n\n-\n\n\nYes\n\n\nThe \nApp\n object to which this box belongs\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ngrid\n\n\nList\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nlayout\n\n\nstring\n\n\n\"auto\"\n\n\n-\n\n\nWhether widgets \ninside this box\n pack themselves (\n\"auto\"\n) or you specify their position on a grid (\n\"grid\"\n)\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nBox\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSets the height of the widget\n\n\n\n\n\n\nlayout\n\n\nstring\n\n\nThe layout being used by the Box (\n\"auto\"\n) or (\n\"grid\"\n)\n\n\n\n\n\n\nmaster\n\n\nApp\n\n\nThe \nApp\n object to which this box belongs\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSets the width of the widget\n\n\n\n\n\n\n\n\nExamples\n\n\nPutting widgets in a Box\n\n\nA \nBox\n object is invisible, but it can contain other widgets. In this example, there are two \nText\n objects. One has \nbox\n as its master, the other has \napp\n as its master.\n\n\nfrom guizero import App, Box, Text\napp = App(title=\"My app\", height=300, width=400)\nbox = Box(app)\ntext1 = Text(box, text=\"Hello from the box\", size=14, text_color=\"red\", font=\"Arial\")\ntext2 = Text(app, text=\"Hello from the app\", size=14, text_color=\"blue\", font=\"Courier New\")\napp.display()\n\n\n\n\n\n\nGrouping objects within a Box\n\n\nIt is useful to put objects in a box to group them together. For example here we have given the \napp\n a grid layout, then placed some text at [0,0] and the \nBox\n object at [1,0]. This means that the text will appear on the left, and the contents of the Box will appear on the right.\n\n\nThe \nBox\n object itself has a grid layout and contains six buttons which are positioned on a \nseparate\n grid layout belonging to the box.\n\n\nfrom guizero import App, Text, Box, PushButton\ndef do_nothing():\n    return 0\n\napp = App(title=\"My app\", height=300, width=300, layout=\"grid\")\ntext = Text(app, text=\"Some text here\", grid=[0,0])\nbox = Box(app, layout=\"grid\", grid=[1,0])\nbutton1 = PushButton(box, command=do_nothing, text=\"1\", grid=[0,0])\nbutton2 = PushButton(box, command=do_nothing, text=\"2\", grid=[1,0])\nbutton3 = PushButton(box, command=do_nothing, text=\"3\", grid=[2,0])\nbutton4 = PushButton(box, command=do_nothing, text=\"4\", grid=[0,1])\nbutton5 = PushButton(box, command=do_nothing, text=\"5\", grid=[1,1])\nbutton6 = PushButton(box, command=do_nothing, text=\"6\", grid=[2,1])\napp.display()",
            "title": "Box"
        },
        {
            "location": "/box/#box",
            "text": "(Contains a  tkinter.Frame  object)  __init__(self, master, layout=\"auto\", grid=None, align=None)",
            "title": "Box"
        },
        {
            "location": "/box/#what-is-it",
            "text": "The  Box  object is an invisible container which can contain other widgets. It is the only object other than  App  which can act as the  master  for other objects and can have its own layout manager.  You can use the  Box  object to group other objects within your GUI.",
            "title": "What is it?"
        },
        {
            "location": "/box/#how-do-i-make-one",
            "text": "Create a  Box  object like this:  from guizero import App, Box\napp = App()\nbox = Box(app)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/box/#starting-parameters",
            "text": "When you create a  Box  object you  must  specify a master, and you can specify any of the optional parameters. Specify parameters in the brackets like this:  box = Box(app, layout=\"grid\")     Parameter  Data type  Default  Compulsory  Description      master  App  -  Yes  The  App  object to which this box belongs    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    grid  List  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    layout  string  \"auto\"  -  Whether widgets  inside this box  pack themselves ( \"auto\" ) or you specify their position on a grid ( \"grid\" )    visible  boolean  True  No  If the widget should be visible.",
            "title": "Starting parameters"
        },
        {
            "location": "/box/#methods",
            "text": "You can call the following methods on a  Box  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the widget if it was previously hidden",
            "title": "Methods"
        },
        {
            "location": "/box/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Sets the height of the widget    layout  string  The layout being used by the Box ( \"auto\" ) or ( \"grid\" )    master  App  The  App  object to which this box belongs    visible  boolean  If this widget is visible    width  size  Sets the width of the widget",
            "title": "Properties"
        },
        {
            "location": "/box/#examples",
            "text": "Putting widgets in a Box  A  Box  object is invisible, but it can contain other widgets. In this example, there are two  Text  objects. One has  box  as its master, the other has  app  as its master.  from guizero import App, Box, Text\napp = App(title=\"My app\", height=300, width=400)\nbox = Box(app)\ntext1 = Text(box, text=\"Hello from the box\", size=14, text_color=\"red\", font=\"Arial\")\ntext2 = Text(app, text=\"Hello from the app\", size=14, text_color=\"blue\", font=\"Courier New\")\napp.display()   Grouping objects within a Box  It is useful to put objects in a box to group them together. For example here we have given the  app  a grid layout, then placed some text at [0,0] and the  Box  object at [1,0]. This means that the text will appear on the left, and the contents of the Box will appear on the right.  The  Box  object itself has a grid layout and contains six buttons which are positioned on a  separate  grid layout belonging to the box.  from guizero import App, Text, Box, PushButton\ndef do_nothing():\n    return 0\n\napp = App(title=\"My app\", height=300, width=300, layout=\"grid\")\ntext = Text(app, text=\"Some text here\", grid=[0,0])\nbox = Box(app, layout=\"grid\", grid=[1,0])\nbutton1 = PushButton(box, command=do_nothing, text=\"1\", grid=[0,0])\nbutton2 = PushButton(box, command=do_nothing, text=\"2\", grid=[1,0])\nbutton3 = PushButton(box, command=do_nothing, text=\"3\", grid=[2,0])\nbutton4 = PushButton(box, command=do_nothing, text=\"4\", grid=[0,1])\nbutton5 = PushButton(box, command=do_nothing, text=\"5\", grid=[1,1])\nbutton6 = PushButton(box, command=do_nothing, text=\"6\", grid=[2,1])\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/buttongroup/",
            "text": "ButtonGroup\n\n\n(Contains a \ntkinter.Frame\n object)\n\n\n__init__(self, master, options, selected, horizontal=False, command=None, grid=None, align=None, args=None)\n\n\nWhat is it?\n\n\nThe \nButtonGroup\n object displays a group of radio buttons, allowing the user to choose a single option.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nButtonGroup\n object like this:\n\n\nfrom guizero import App, ButtonGroup\napp = App()\nchoice = ButtonGroup(app, options=[\"cheese\", \"ham\", \"salad\"], selected=1)\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nButtonGroup\n object you \nmust\n specify \nmaster\n and \notions\n and you can specify any of the optional parameters. Specify parameters in the brackets like this: \nchoice = ButtonGroup(app, options=[\"cheese\", \"ham\", \"salad\"], selected=1)\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\noptions\n\n\nlist or 2D List\n\n\n-\n\n\nYes\n\n\nEither a list or a 2D list of [text, value] pairs. If a 2D list is specified, the first item in the pair will be displayed on the interface, and the second item will be a hidden value associated with this option. If a list is specified, the options will be automatically numbered with hidden values, beginning at 1.\n\n\n\n\n\n\nselected\n\n\nstring\n\n\n-\n\n\n-\n\n\nThe option that should be selected, if a value isn't provided the first option will be selected. If the options are specified as a list, the selected option should be the number of the desired option, beginning at 1. If a 2D list is specified, this should be the \nhidden value\n associated with one of the options.\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when the selected option changes.\n\n\n\n\n\n\nargs\n\n\nlist\n\n\nNone\n\n\n-\n\n\nIf you wish to pass any arguments to the function specified in the command parameter, you can specify them as a list\n\n\n\n\n\n\ngrid\n\n\nlist [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nhorizontal\n\n\nboolean\n\n\nFalse\n\n\n-\n\n\nWhether the buttons stack vertically or horizontally. (Defaults to vertical)\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be enabled.\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on an \nButtonGroup\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nget_group_as_list()\n\n\n-\n\n\nlist\n\n\nReturns a list containing all of the text/hidden value pairs from the ButtonGroup (useful for debugging)\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\nupdate_command(command, args =None)\n\n\ncommand (function name), args (\nOptional\n List of arguments to be passed to command)\n\n\n-\n\n\nUpdates the function to call when the selected option changes\n\n\n\n\n\n\nget()\n\n\n-\n\n\nstring\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\nset(value)\n\n\nvalue (string)\n\n\n-\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\n\n\nParameters in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSets the height of the widget\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe hidden value associated with the currently selected option\n\n\n\n\n\n\nvalue_text\n\n\nstring\n\n\nThe text associated with the currently selected option\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSets the width of the widget\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nButtonGroup\n object is called \nchoice\n you would write \nchoice.value\n.\n\n\nYou can \nset\n the property (for example \nchoice.value = \"2\"\n) or \nget\n the value of the property to use (for example \nprint(choice.value)\n).\n\n\nExamples\n\n\nCreating a ButtonGroup with a 2D list\n\n\nIf you want to create a ButtonGroup object with your own hidden values you can specify a 2D list of options:\n\n\nfrom guizero import App, ButtonGroup, Text\n\ndef update_text():\n    what_is_selected.value = activities.value\n\napp = App()\nactivities = ButtonGroup(app, options=[\n                              [\"Roller Skating\", \"skate\"],\n                              [\"White water rafting\", \"WWR\"],\n                              [\"Mountain climbing\", \"climb\"]\n                            ],\n                            selected=\"skate\", command=update_text)\n\nwhat_is_selected = Text(app, text=\"skate\")\napp.display()",
            "title": "ButtonGroup"
        },
        {
            "location": "/buttongroup/#buttongroup",
            "text": "(Contains a  tkinter.Frame  object)  __init__(self, master, options, selected, horizontal=False, command=None, grid=None, align=None, args=None)",
            "title": "ButtonGroup"
        },
        {
            "location": "/buttongroup/#what-is-it",
            "text": "The  ButtonGroup  object displays a group of radio buttons, allowing the user to choose a single option.",
            "title": "What is it?"
        },
        {
            "location": "/buttongroup/#how-do-i-make-one",
            "text": "Create a  ButtonGroup  object like this:  from guizero import App, ButtonGroup\napp = App()\nchoice = ButtonGroup(app, options=[\"cheese\", \"ham\", \"salad\"], selected=1)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/buttongroup/#starting-parameters",
            "text": "When you create a  ButtonGroup  object you  must  specify  master  and  otions  and you can specify any of the optional parameters. Specify parameters in the brackets like this:  choice = ButtonGroup(app, options=[\"cheese\", \"ham\", \"salad\"], selected=1)     Parameter  Takes  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    options  list or 2D List  -  Yes  Either a list or a 2D list of [text, value] pairs. If a 2D list is specified, the first item in the pair will be displayed on the interface, and the second item will be a hidden value associated with this option. If a list is specified, the options will be automatically numbered with hidden values, beginning at 1.    selected  string  -  -  The option that should be selected, if a value isn't provided the first option will be selected. If the options are specified as a list, the selected option should be the number of the desired option, beginning at 1. If a 2D list is specified, this should be the  hidden value  associated with one of the options.    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    command  function name  None  -  The name of a function to call when the selected option changes.    args  list  None  -  If you wish to pass any arguments to the function specified in the command parameter, you can specify them as a list    grid  list [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    horizontal  boolean  False  -  Whether the buttons stack vertically or horizontally. (Defaults to vertical)    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  True  No  If the widget should be enabled.",
            "title": "Starting parameters"
        },
        {
            "location": "/buttongroup/#methods",
            "text": "You can call the following methods on an  ButtonGroup  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget    get_group_as_list()  -  list  Returns a list containing all of the text/hidden value pairs from the ButtonGroup (useful for debugging)    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the widget if it was previously hidden    update_command(command, args =None)  command (function name), args ( Optional  List of arguments to be passed to command)  -  Updates the function to call when the selected option changes    get()  -  string  Replaced by  value  property    set(value)  value (string)  -  Replaced by  value  property     Parameters in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/buttongroup/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    font  string  The font of the text    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Sets the height of the widget    master  App or Box  The container to which this widget belongs    value  string  The hidden value associated with the currently selected option    value_text  string  The text associated with the currently selected option    visible  boolean  If this widget is visible    width  size  Sets the width of the widget    text_size  int  The size of the text    text_color  color  The colour of the text     Refer to a property as  <name of widget>.property . For example, if your  ButtonGroup  object is called  choice  you would write  choice.value .  You can  set  the property (for example  choice.value = \"2\" ) or  get  the value of the property to use (for example  print(choice.value) ).",
            "title": "Properties"
        },
        {
            "location": "/buttongroup/#examples",
            "text": "Creating a ButtonGroup with a 2D list  If you want to create a ButtonGroup object with your own hidden values you can specify a 2D list of options:  from guizero import App, ButtonGroup, Text\n\ndef update_text():\n    what_is_selected.value = activities.value\n\napp = App()\nactivities = ButtonGroup(app, options=[\n                              [\"Roller Skating\", \"skate\"],\n                              [\"White water rafting\", \"WWR\"],\n                              [\"Mountain climbing\", \"climb\"]\n                            ],\n                            selected=\"skate\", command=update_text)\n\nwhat_is_selected = Text(app, text=\"skate\")\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/checkbox/",
            "text": "CheckBox\n\n\n(Contains a \ntkinter.Checkbutton\n object)\n\n\n__init__(self, master, text, command=None, grid=None, align=None, args=None)\n\n\nWhat is it?\n\n\nThe \nCheckBox\n object displays a check box to allow an option to be ticked or unticked\n\n\n\n\nHow do I make one?\n\n\nCreate a \nCheckBox\n object like this:\n\n\nfrom guizero import App, CheckBox\napp = App()\ncheckbox = CheckBox(app, text=\"Add extra glitter\")\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nCheckBox\n object you \nmust\n specify \nmaster\n and \ntext\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \ncheckbox = CheckBox(app, text=\"Add extra glitter\")\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\ntext\n\n\nstring\n\n\n-\n\n\nYes\n\n\nThe text to display next to the check box\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when this checkbox is ticked/unticked\n\n\n\n\n\n\nargs\n\n\nlist\n\n\nNone\n\n\n-\n\n\nIf you wish to pass any arguments to the function specified in the command parameter, you can specify them as a list\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be enabled.\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nCheckBox\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\ntoggle()\n\n\n-\n\n\n-\n\n\nSwitches the \nCheckBox\n to the opposite of its current value. i.e. if it is ticked, untick it and vice versa\n\n\n\n\n\n\nupdate_command(command, args =None)\n\n\ncommand (function name), args (\nOptional\n List of arguments to be passed to command)\n\n\n-\n\n\nUpdates the function to call when the checkbox is ticked/unticked\n\n\n\n\n\n\nchange_text(newtext)\n\n\nnewtext (string)\n\n\n-\n\n\nReplaced by the \ntext\n property\n\n\n\n\n\n\nget_text()\n\n\n-\n\n\nstring\n\n\nReplaced by the \ntext\n property\n\n\n\n\n\n\nget_value()\n\n\n-\n\n\nint\n\n\nReplaced by the \nvalue\n property\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSets the height of the widget\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\ntext\n\n\nstring\n\n\nThe text associated with the checkbox\n\n\n\n\n\n\nvalue\n\n\nint\n\n\n1\n if the CheckBox is ticked or \n0\n if it is not ticked\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSets the width of the widget\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nCheckBox\n object is called \ncheckbox\n you would write \ncheckbox.value\n.\n\n\nYou can \nset\n the property (for example \ncheckbox.value = 1\n) or \nget\n the value of the property to use (for example \nprint(checkbox.value)\n).\n\n\nExamples\n\n\nCreating multiple CheckBoxes\n\n\nCreate multiple CheckBoxes like this.\n\n\nfrom guizero import App, CheckBox\napp = App()\nglitter = CheckBox(app, text=\"Add glitter\")\nsparkles = CheckBox(app, text=\"Add sparkles\")\napp.display()\n\n\n\n\nCalling a function when a CheckBox value changes\n\n\nYou can call a function when the value of a CheckBox changes (becomes checked or unchecked). In this particular example all three CheckBoxes call the same function, but it is possible for each CheckBox object to call a different function.\n\n\nfrom guizero import App, Text, CheckBox, TextBox\ndef calculate_extras():\n    total = 0\n    if syrup.value == 1:\n        total += 20\n    if sprinkles.value == 1:\n        total += 10\n    if cream.value == 1:\n        total += 50\n    cost.value = total\n\n\napp = App()\n\nquestions = Text(app, text=\"What would you like with your coffee?\")\n\nsyrup = CheckBox(app, text=\"Caramel syrup (20p)\", command=calculate_extras)\nsprinkles = CheckBox(app, text=\"Chocolate sprinkles (10p)\", command=calculate_extras)\ncream = CheckBox(app, text=\"Whipped cream (50p)\", command=calculate_extras)\n\ncost_of_extras = Text(app, text=\"Cost of extras:\")\ncost = TextBox(app, text=\"0\")\n\napp.display()",
            "title": "CheckBox"
        },
        {
            "location": "/checkbox/#checkbox",
            "text": "(Contains a  tkinter.Checkbutton  object)  __init__(self, master, text, command=None, grid=None, align=None, args=None)",
            "title": "CheckBox"
        },
        {
            "location": "/checkbox/#what-is-it",
            "text": "The  CheckBox  object displays a check box to allow an option to be ticked or unticked",
            "title": "What is it?"
        },
        {
            "location": "/checkbox/#how-do-i-make-one",
            "text": "Create a  CheckBox  object like this:  from guizero import App, CheckBox\napp = App()\ncheckbox = CheckBox(app, text=\"Add extra glitter\")\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/checkbox/#starting-parameters",
            "text": "When you create a  CheckBox  object you  must  specify  master  and  text  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  checkbox = CheckBox(app, text=\"Add extra glitter\")     Parameter  Takes  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    text  string  -  Yes  The text to display next to the check box    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    command  function name  None  -  The name of a function to call when this checkbox is ticked/unticked    args  list  None  -  If you wish to pass any arguments to the function specified in the command parameter, you can specify them as a list    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  True  No  If the widget should be enabled.",
            "title": "Starting parameters"
        },
        {
            "location": "/checkbox/#methods",
            "text": "You can call the following methods on a  CheckBox  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the widget if it was previously hidden    toggle()  -  -  Switches the  CheckBox  to the opposite of its current value. i.e. if it is ticked, untick it and vice versa    update_command(command, args =None)  command (function name), args ( Optional  List of arguments to be passed to command)  -  Updates the function to call when the checkbox is ticked/unticked    change_text(newtext)  newtext (string)  -  Replaced by the  text  property    get_text()  -  string  Replaced by the  text  property    get_value()  -  int  Replaced by the  value  property     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/checkbox/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    font  string  The font of the text    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Sets the height of the widget    master  App or Box  The container to which this widget belongs    text  string  The text associated with the checkbox    value  int  1  if the CheckBox is ticked or  0  if it is not ticked    visible  boolean  If this widget is visible    width  size  Sets the width of the widget    text_size  int  The size of the text    text_color  color  The colour of the text     Refer to a property as  <name of widget>.property . For example, if your  CheckBox  object is called  checkbox  you would write  checkbox.value .  You can  set  the property (for example  checkbox.value = 1 ) or  get  the value of the property to use (for example  print(checkbox.value) ).",
            "title": "Properties"
        },
        {
            "location": "/checkbox/#examples",
            "text": "Creating multiple CheckBoxes  Create multiple CheckBoxes like this.  from guizero import App, CheckBox\napp = App()\nglitter = CheckBox(app, text=\"Add glitter\")\nsparkles = CheckBox(app, text=\"Add sparkles\")\napp.display()  Calling a function when a CheckBox value changes  You can call a function when the value of a CheckBox changes (becomes checked or unchecked). In this particular example all three CheckBoxes call the same function, but it is possible for each CheckBox object to call a different function.  from guizero import App, Text, CheckBox, TextBox\ndef calculate_extras():\n    total = 0\n    if syrup.value == 1:\n        total += 20\n    if sprinkles.value == 1:\n        total += 10\n    if cream.value == 1:\n        total += 50\n    cost.value = total\n\n\napp = App()\n\nquestions = Text(app, text=\"What would you like with your coffee?\")\n\nsyrup = CheckBox(app, text=\"Caramel syrup (20p)\", command=calculate_extras)\nsprinkles = CheckBox(app, text=\"Chocolate sprinkles (10p)\", command=calculate_extras)\ncream = CheckBox(app, text=\"Whipped cream (50p)\", command=calculate_extras)\n\ncost_of_extras = Text(app, text=\"Cost of extras:\")\ncost = TextBox(app, text=\"0\")\n\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/combo/",
            "text": "Combo\n\n\n(Contains a \ntkinter.OptionMenu\n object)\n\n\n__init__(self, master, options, selected=None, command=None, grid=None, align=None)\n\n\nWhat is it?\n\n\nThe \nCombo\n object displays a drop down box allowing a single option to be selected from a list of options.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nCombo\n object like this:\n\n\nfrom guizero import App, Combo\napp = App()\ncombo = Combo(app, options=[\"Beef\", \"Chicken\", \"Fish\", \"Vegetarian\"])\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nCombo\n object you \nmust\n specify \nmaster\n and \noptions\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \ncombo = Combo(app, options=[\"Beef\", \"Chicken\", \"Fish\", \"Vegetarian\"])\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nselected\n\n\nstring\n\n\nNone\n\n\nNo\n\n\nThe option to select by default\n\n\n\n\n\n\noptions\n\n\nList\n\n\n-\n\n\nYes\n\n\nA list of options to display\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when a different option is selected. This function MUST take either zero or one argument, if the function takes one argument the current value of the Combo will be given.\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be enabled.\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nCombo\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nadd_option(option)\n\n\noption (string)\n\n\n-\n\n\nAdds a new item to the combo box with the value \noption\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\nclear()\n\n\n-\n\n\n-\n\n\nRemoves all options from the Combo box\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nselect_default()\n\n\n-\n\n\n-\n\n\nResets the combo box so that the first item is selected\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\nupdate_command(command)\n\n\ncommand (function name)\n\n\n-\n\n\nUpdates the function to call when a different option is selected.\n\n\n\n\n\n\nget()\n\n\n-\n\n\nstring\n\n\nReplaced by the \nvalue\n property\n\n\n\n\n\n\nset(text)\n\n\ntext (string)\n\n\n-\n\n\nReplaced by the \nvalue\n property\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSets the height of the widget\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe text associated with the currently selected option\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSets the width of the widget\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nCombo\n object is called \ncombo\n you would write \ncombo.value\n.\n\n\nYou can \nset\n the property (for example \ncombo.value = \"Chicken\"\n) or \nget\n the value of the property to use (for example \nprint(combo.value)\n).\n\n\nExamples\n\n\nCalling a function when the value selected changes\n\n\nYou can call a function when the selected value in a \nCombo\n object changes. This must be set up at the time you create the \nCombo\n object and cannot be defined later. The function you call \nMUST\n take a minimum of one argument as it will automatically be passed a string containing the currently selected value from the \nCombo\n object.\n\n\nfrom guizero import App, Text, Combo\ndef you_chose(selected_value):\n    if selected_value == \"Tiny goblet\":\n        result.value = \"You chose...wisely\"\n    else:\n        result.value = \"You chose...poorly\"\n\napp = App()\ninstructions = Text(app, text=\"Choose a goblet\")\ncombo = Combo(app, options=[\"\", \"Huge golden goblet\", \"Jewel encrusted goblet\", \"Tiny goblet\"], command=you_chose)\nresult = Text(app)\napp.display()",
            "title": "Combo"
        },
        {
            "location": "/combo/#combo",
            "text": "(Contains a  tkinter.OptionMenu  object)  __init__(self, master, options, selected=None, command=None, grid=None, align=None)",
            "title": "Combo"
        },
        {
            "location": "/combo/#what-is-it",
            "text": "The  Combo  object displays a drop down box allowing a single option to be selected from a list of options.",
            "title": "What is it?"
        },
        {
            "location": "/combo/#how-do-i-make-one",
            "text": "Create a  Combo  object like this:  from guizero import App, Combo\napp = App()\ncombo = Combo(app, options=[\"Beef\", \"Chicken\", \"Fish\", \"Vegetarian\"])\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/combo/#starting-parameters",
            "text": "When you create a  Combo  object you  must  specify  master  and  options  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  combo = Combo(app, options=[\"Beef\", \"Chicken\", \"Fish\", \"Vegetarian\"])     Parameter  Takes  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    selected  string  None  No  The option to select by default    options  List  -  Yes  A list of options to display    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    command  function name  None  -  The name of a function to call when a different option is selected. This function MUST take either zero or one argument, if the function takes one argument the current value of the Combo will be given.    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  True  No  If the widget should be enabled.",
            "title": "Starting parameters"
        },
        {
            "location": "/combo/#methods",
            "text": "You can call the following methods on a  Combo  object.     Method  Takes  Returns  Description      add_option(option)  option (string)  -  Adds a new item to the combo box with the value  option    after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    clear()  -  -  Removes all options from the Combo box    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    select_default()  -  -  Resets the combo box so that the first item is selected    show()  -  -  Displays the widget if it was previously hidden    update_command(command)  command (function name)  -  Updates the function to call when a different option is selected.    get()  -  string  Replaced by the  value  property    set(text)  text (string)  -  Replaced by the  value  property     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/combo/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    font  string  The font of the text    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Sets the height of the widget    master  App or Box  The container to which this widget belongs    value  string  The text associated with the currently selected option    visible  boolean  If this widget is visible    width  size  Sets the width of the widget    text_size  int  The size of the text    text_color  color  The colour of the text     Refer to a property as  <name of widget>.property . For example, if your  Combo  object is called  combo  you would write  combo.value .  You can  set  the property (for example  combo.value = \"Chicken\" ) or  get  the value of the property to use (for example  print(combo.value) ).",
            "title": "Properties"
        },
        {
            "location": "/combo/#examples",
            "text": "Calling a function when the value selected changes  You can call a function when the selected value in a  Combo  object changes. This must be set up at the time you create the  Combo  object and cannot be defined later. The function you call  MUST  take a minimum of one argument as it will automatically be passed a string containing the currently selected value from the  Combo  object.  from guizero import App, Text, Combo\ndef you_chose(selected_value):\n    if selected_value == \"Tiny goblet\":\n        result.value = \"You chose...wisely\"\n    else:\n        result.value = \"You chose...poorly\"\n\napp = App()\ninstructions = Text(app, text=\"Choose a goblet\")\ncombo = Combo(app, options=[\"\", \"Huge golden goblet\", \"Jewel encrusted goblet\", \"Tiny goblet\"], command=you_chose)\nresult = Text(app)\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/menubar/",
            "text": "MenuBar\n\n\n(Contains a \ntkinter.Menu\n object)\n\n\n__init__(self, master, toplevel, options)\n\n\nWhat is it?\n\n\nThe \nMenuBar\n object displays a menu at the top of the screen, with each menu option leading to a submenu.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nMenuBar\n object like this:\n\n\nfrom guizero import App, MenuBar\ndef file_function():\n    print(\"File option\")\n\ndef edit_function():\n    print(\"Edit option\")\n\napp = App()\nmenubar = MenuBar(app,\n                  toplevel=[\"File\", \"Edit\"],\n                  options=[\n                      [ [\"File option 1\", file_function], [\"File option 2\", file_function] ],\n                      [ [\"Edit option 1\", edit_function], [\"Edit option 2\", edit_function] ]\n                  ])\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nMenuBar\n object you \nmust\n specify all of the parameters.\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\ntoplevel\n\n\nlist\n\n\n-\n\n\nYes\n\n\nA list of top level menu items\n\n\n\n\n\n\noptions\n\n\n3D list\n\n\n-\n\n\nYes\n\n\nA list of submenus, with each submenu being a list of options and each option being a text/command pair. See notes above for more details.\n\n\n\n\n\n\n\n\nThe \ntoplevel\n parameter should be a list of options you wish to display on the menu. In the example, the \ntoplevel\n options are File and Edit:\n\n\n\n\nThe options parameter should be a 3D List containing lists of submenu items, which are themselves lists. The elements in the list correspond to the elements in the \ntoplevel\n list, so the first list of submenu items provided in \noptions\n will be the submenu for the first menu heading provided in \ntoplevel\n and so on.\n\n\nThe menu item sub-sublists within \noptions\n should contain pairs consisting of the text to display on the menu and the function to call when that option is selected. In this example, the text \"File option 1\" is displayed and the function \nfile_function\n is called if this option is clicked on.\n\n\n[\"File option 1\", file_function]\n\n\n\n\nThe MenuBar is never displayed on a grid so there are no grid or alignment parameters.\n\n\nMethods\n\n\nYou can call the following methods on an \nMenuBar\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp\n\n\nThe \nApp\n object to which this MenuBar belongs",
            "title": "MenuBar"
        },
        {
            "location": "/menubar/#menubar",
            "text": "(Contains a  tkinter.Menu  object)  __init__(self, master, toplevel, options)",
            "title": "MenuBar"
        },
        {
            "location": "/menubar/#what-is-it",
            "text": "The  MenuBar  object displays a menu at the top of the screen, with each menu option leading to a submenu.",
            "title": "What is it?"
        },
        {
            "location": "/menubar/#how-do-i-make-one",
            "text": "Create a  MenuBar  object like this:  from guizero import App, MenuBar\ndef file_function():\n    print(\"File option\")\n\ndef edit_function():\n    print(\"Edit option\")\n\napp = App()\nmenubar = MenuBar(app,\n                  toplevel=[\"File\", \"Edit\"],\n                  options=[\n                      [ [\"File option 1\", file_function], [\"File option 2\", file_function] ],\n                      [ [\"Edit option 1\", edit_function], [\"Edit option 2\", edit_function] ]\n                  ])\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/menubar/#starting-parameters",
            "text": "When you create a  MenuBar  object you  must  specify all of the parameters.     Parameter  Takes  Default  Compulsory  Description      master  App  -  Yes  The container to which this widget belongs    toplevel  list  -  Yes  A list of top level menu items    options  3D list  -  Yes  A list of submenus, with each submenu being a list of options and each option being a text/command pair. See notes above for more details.     The  toplevel  parameter should be a list of options you wish to display on the menu. In the example, the  toplevel  options are File and Edit:   The options parameter should be a 3D List containing lists of submenu items, which are themselves lists. The elements in the list correspond to the elements in the  toplevel  list, so the first list of submenu items provided in  options  will be the submenu for the first menu heading provided in  toplevel  and so on.  The menu item sub-sublists within  options  should contain pairs consisting of the text to display on the menu and the function to call when that option is selected. In this example, the text \"File option 1\" is displayed and the function  file_function  is called if this option is clicked on.  [\"File option 1\", file_function]  The MenuBar is never displayed on a grid so there are no grid or alignment parameters.",
            "title": "Starting parameters"
        },
        {
            "location": "/menubar/#methods",
            "text": "You can call the following methods on an  MenuBar  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.",
            "title": "Methods"
        },
        {
            "location": "/menubar/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      master  App  The  App  object to which this MenuBar belongs",
            "title": "Properties"
        },
        {
            "location": "/picture/",
            "text": "Picture\n\n\n(Contains a \ntkinter.Label\n object)\n\n\n__init__(self, master, image, grid=None, align=None)\n\n\nWhat is it?\n\n\nThe \nPicture\n object displays an image.\n\n\n\n\nWindows & Linux support GIF and PNG file types, MacOS only supports GIF.\n\n\nHow do I make one?\n\n\nCreate a \nPicture\n object like this:\n\n\nfrom guizero import App, Picture\napp = App()\npicture = Picture(app, image=\"test.gif\")\napp.display()\n\n\n\n\nYou must specify the correct path to the image. The image in the example is in the same directory as the program. If the image is in a different directory, specify a relative path, for example if the picture is in a subfolder called \nimages\n you would write:\n\n\npicture = Picture(app, image=\"images/test.gif\")\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nPicture\n object you \nmust\n specify \nmaster\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \npicture = Picture(app, image=\"test.gif\")\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nimage\n\n\nstring\n\n\nNone\n\n\n-\n\n\nThe file path, tkinter.PhotoImage or PIL.Image you wish to display\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be enabled.\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nPicture\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\nset(image)\n\n\nimage (string)\n\n\n-\n\n\nReplaced by the \nvalue\n property\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSets the height of the widget\n\n\n\n\n\n\nimage\n\n\nstring\n\n\nThe file path, tkinter.PhotoImage or PIL.Image you wish to display\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe file path, tkinter.PhotoImage or PIL.Image you wish to display\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSets the width of the widget\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nPicture\n object is called \npicture\n you would write \npicture.value\n.\n\n\nYou can \nset\n the property (for example \npicture.value = \"star.gif\"\n) or \nget\n the value of the property to use (for example \nprint(picture.value)\n).\n\n\nImage types",
            "title": "Picture"
        },
        {
            "location": "/picture/#picture",
            "text": "(Contains a  tkinter.Label  object)  __init__(self, master, image, grid=None, align=None)",
            "title": "Picture"
        },
        {
            "location": "/picture/#what-is-it",
            "text": "The  Picture  object displays an image.   Windows & Linux support GIF and PNG file types, MacOS only supports GIF.",
            "title": "What is it?"
        },
        {
            "location": "/picture/#how-do-i-make-one",
            "text": "Create a  Picture  object like this:  from guizero import App, Picture\napp = App()\npicture = Picture(app, image=\"test.gif\")\napp.display()  You must specify the correct path to the image. The image in the example is in the same directory as the program. If the image is in a different directory, specify a relative path, for example if the picture is in a subfolder called  images  you would write:  picture = Picture(app, image=\"images/test.gif\")",
            "title": "How do I make one?"
        },
        {
            "location": "/picture/#starting-parameters",
            "text": "When you create a  Picture  object you  must  specify  master  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  picture = Picture(app, image=\"test.gif\")     Parameter  Takes  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    image  string  None  -  The file path, tkinter.PhotoImage or PIL.Image you wish to display    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  True  No  If the widget should be enabled.",
            "title": "Starting parameters"
        },
        {
            "location": "/picture/#methods",
            "text": "You can call the following methods on a  Picture  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the widget if it was previously hidden    set(image)  image (string)  -  Replaced by the  value  property     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/picture/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Sets the height of the widget    image  string  The file path, tkinter.PhotoImage or PIL.Image you wish to display    master  App or Box  The container to which this widget belongs    value  string  The file path, tkinter.PhotoImage or PIL.Image you wish to display    visible  boolean  If this widget is visible    width  size  Sets the width of the widget     Refer to a property as  <name of widget>.property . For example, if your  Picture  object is called  picture  you would write  picture.value .  You can  set  the property (for example  picture.value = \"star.gif\" ) or  get  the value of the property to use (for example  print(picture.value) ).",
            "title": "Properties"
        },
        {
            "location": "/picture/#image-types",
            "text": "",
            "title": "Image types"
        },
        {
            "location": "/pushbutton/",
            "text": "PushButton\n\n\n(Contains a \ntkinter.Button\n object)\n\n\n__init__(self, master, command=None, args=None, text=\"Button\", image=None, pady=10, padx=10, grid=None, align=None)\n\n\nWhat is it?\n\n\nThe \nPushButton\n object displays a button with text or an image, which calls a function when pressed.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nPushButton\n object like this:\n\n\nfrom guizero import App, PushButton\ndef do_nothing():\n  print(\"Button was pressed\")\n\napp = App()\nbutton = PushButton(app, command=do_nothing)\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nPushButton\n object you \nmust\n specify \nmaster\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \nbutton = PushButton(app)\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when the button is pressed.\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nargs\n\n\nlist\n\n\nNone\n\n\n-\n\n\nIf you wish to pass any arguments to the function specified in the command parameter, you can specify them as a list\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nimage\n\n\nstring\n\n\nNone\n\n\n-\n\n\nThe file path, tkinter.PhotoImage or PIL.Image you wish to display. If both an image and text are specified, the image will override the text.\n\n\n\n\n\n\npadx\n\n\nint\n\n\n10\n\n\n-\n\n\nHow much horizontal padding to add between the text/icon and the edge of the button.\n\n\n\n\n\n\npady\n\n\nint\n\n\n10\n\n\n-\n\n\nHow much vertical padding to add between the text/icon and the edge of the button.\n\n\n\n\n\n\ntext\n\n\nstring\n\n\n\"Button\"\n\n\n-\n\n\nThe text to display on the button\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be enabled.\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nPushButton\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nimage(image_source)\n\n\nimage_source (string)\n\n\n-\n\n\nThe file path, tkinter.PhotoImage or PIL.Image you wish to display.\n\n\n\n\n\n\npadding(padx, pady)\n\n\npadx (int), pady(int)\n\n\n-\n\n\nSets the amount of x (horizontal) and y (vertical) padding between the text/icon and the edge of the button\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\ntoggle()\n\n\n-\n\n\n-\n\n\nChanges the state of the button to the opposite of its current state - if it is currently enabled, disable it and vice versa.\n\n\n\n\n\n\nupdate_command(command, args =None)\n\n\ncommand (function name), args (\nOptional\n List of arguments to be passed to command)\n\n\n-\n\n\nUpdates the function to call when the button is pressed .\n\n\n\n\n\n\nchange_command(newcommand, args)\n\n\nnewcommand (function name), args (list)\n\n\n-\n\n\nReplaced by update_command function\n\n\n\n\n\n\nicon(icon)\n\n\nicon (string)\n\n\n-\n\n\nThe file path, tkinter.PhotoImage or PIL.Image you wish to display\n\n\n\n\n\n\nset_text(text)\n\n\ntext (string)\n\n\n-\n\n\nReplaced by the \ntext\n property\n\n\n\n\n\n\ntoggle_state()\n\n\n-\n\n\n-\n\n\nRenamed to \ntoggle()\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text on the button\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSets the height of the widget\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\ntext\n\n\nstring\n\n\nThe text on the button\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text on the button\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text on the button\n\n\n\n\n\n\nvalue\n\n\nint\n\n\nReturns 1 when the button is pressed, 0 if the button is released\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSets the width of the widget\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nPushButton\n object is called \nbutton\n you would write \nbutton.value\n.\n\n\nYou can \nset\n the property (for example \nbutton.bg = \"red\"\n) or \nget\n the value of the property to use (for example \nprint(button.bg)\n).",
            "title": "PushButton"
        },
        {
            "location": "/pushbutton/#pushbutton",
            "text": "(Contains a  tkinter.Button  object)  __init__(self, master, command=None, args=None, text=\"Button\", image=None, pady=10, padx=10, grid=None, align=None)",
            "title": "PushButton"
        },
        {
            "location": "/pushbutton/#what-is-it",
            "text": "The  PushButton  object displays a button with text or an image, which calls a function when pressed.",
            "title": "What is it?"
        },
        {
            "location": "/pushbutton/#how-do-i-make-one",
            "text": "Create a  PushButton  object like this:  from guizero import App, PushButton\ndef do_nothing():\n  print(\"Button was pressed\")\n\napp = App()\nbutton = PushButton(app, command=do_nothing)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/pushbutton/#starting-parameters",
            "text": "When you create a  PushButton  object you  must  specify  master  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  button = PushButton(app)     Parameter  Takes  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    command  function name  None  -  The name of a function to call when the button is pressed.    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    args  list  None  -  If you wish to pass any arguments to the function specified in the command parameter, you can specify them as a list    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    image  string  None  -  The file path, tkinter.PhotoImage or PIL.Image you wish to display. If both an image and text are specified, the image will override the text.    padx  int  10  -  How much horizontal padding to add between the text/icon and the edge of the button.    pady  int  10  -  How much vertical padding to add between the text/icon and the edge of the button.    text  string  \"Button\"  -  The text to display on the button    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  True  No  If the widget should be enabled.",
            "title": "Starting parameters"
        },
        {
            "location": "/pushbutton/#methods",
            "text": "You can call the following methods on a  PushButton  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    image(image_source)  image_source (string)  -  The file path, tkinter.PhotoImage or PIL.Image you wish to display.    padding(padx, pady)  padx (int), pady(int)  -  Sets the amount of x (horizontal) and y (vertical) padding between the text/icon and the edge of the button    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the widget if it was previously hidden    toggle()  -  -  Changes the state of the button to the opposite of its current state - if it is currently enabled, disable it and vice versa.    update_command(command, args =None)  command (function name), args ( Optional  List of arguments to be passed to command)  -  Updates the function to call when the button is pressed .    change_command(newcommand, args)  newcommand (function name), args (list)  -  Replaced by update_command function    icon(icon)  icon (string)  -  The file path, tkinter.PhotoImage or PIL.Image you wish to display    set_text(text)  text (string)  -  Replaced by the  text  property    toggle_state()  -  -  Renamed to  toggle()     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/pushbutton/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    font  string  The font of the text on the button    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Sets the height of the widget    master  App or Box  The container to which this widget belongs    text  string  The text on the button    text_color  color  The colour of the text on the button    text_size  int  The size of the text on the button    value  int  Returns 1 when the button is pressed, 0 if the button is released    visible  boolean  If this widget is visible    width  size  Sets the width of the widget     Refer to a property as  <name of widget>.property . For example, if your  PushButton  object is called  button  you would write  button.value .  You can  set  the property (for example  button.bg = \"red\" ) or  get  the value of the property to use (for example  print(button.bg) ).",
            "title": "Properties"
        },
        {
            "location": "/slider/",
            "text": "Slider\n\n\n(Contains a \ntkinter.Scale\n object)\n\n\n__init__(self, master, start=0, end=100, horizontal=True, command=None, grid=None, align=None)\n\n\nWhat is it?\n\n\nThe \nSlider\n object displays a bar and selector which can be used to specify a value in a range.\n\n\nThe above code looks like this on Windows:\n\n\n\nHow do I make one?\n\n\nCreate a \nSlider\n object like this:\n\n\nfrom guizero import App, Slider\napp = App()\nslider = Slider(app)\napp.display()\n\n\n\n\nStarting paramters\n\n\nWhen you create a \nSlider\n object, you \nmust\n specify a \nmaster\n and you can specify any of the the optional parameters. Specify parameters in the brackets, like this: \nslider = Slider(app, horizontal=False)\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when the slider value is changed\n\n\n\n\n\n\nend\n\n\nint\n\n\n100\n\n\n-\n\n\nThe largest value selectable on the slider\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nhorizontal\n\n\nBoolean\n\n\nTrue\n\n\n-\n\n\nWhether you wish to display your slider horizontally or vertically (defaults to horizontal)\n\n\n\n\n\n\nstart\n\n\nint\n\n\n0\n\n\n-\n\n\nThe smallest value selectable on the slider\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be enabled.\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nSlider\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nthe function specified in \ncommand\n\n\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\nupdate_command(command)\n\n\ncommand (function name)\n\n\n-\n\n\nUpdates the function to call when the slider value is changed\n\n\n\n\n\n\nadd_command(command)\n\n\ncommand (function name)\n\n\n-\n\n\nSets the function called when the slider value is changed to\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSets the height of the widget\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe current value of the slider\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSets the width of the widget\n\n\n\n\n\n\n\n\nExamples\n\n\nCalling a function when the slider value changes\n\n\nYou can specify a function to call when the slider value changes. Your function \nMUST\n have a minimum of one parameter as it will automatically receive a string containing the value of the slider (called \nslider_value\n in the example) when it is called.\n\n\nThis code has a slider and a text box, and the text box updates automatically to display the current value of the slider.\n\n\n\n\nfrom guizero import App, Slider, TextBox\ndef slider_changed(slider_value):\n    textbox.value = slider_value\n\napp = App()\nslider = Slider(app, command=slider_changed)\ntextbox = TextBox(app)\napp.display()",
            "title": "Slider"
        },
        {
            "location": "/slider/#slider",
            "text": "(Contains a  tkinter.Scale  object)  __init__(self, master, start=0, end=100, horizontal=True, command=None, grid=None, align=None)",
            "title": "Slider"
        },
        {
            "location": "/slider/#what-is-it",
            "text": "The  Slider  object displays a bar and selector which can be used to specify a value in a range.  The above code looks like this on Windows:",
            "title": "What is it?"
        },
        {
            "location": "/slider/#how-do-i-make-one",
            "text": "Create a  Slider  object like this:  from guizero import App, Slider\napp = App()\nslider = Slider(app)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/slider/#starting-paramters",
            "text": "When you create a  Slider  object, you  must  specify a  master  and you can specify any of the the optional parameters. Specify parameters in the brackets, like this:  slider = Slider(app, horizontal=False)     Parameter  Takes  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    command  function name  None  -  The name of a function to call when the slider value is changed    end  int  100  -  The largest value selectable on the slider    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    horizontal  Boolean  True  -  Whether you wish to display your slider horizontally or vertically (defaults to horizontal)    start  int  0  -  The smallest value selectable on the slider    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  True  No  If the widget should be enabled.",
            "title": "Starting paramters"
        },
        {
            "location": "/slider/#methods",
            "text": "You can call the following methods on a  Slider  object.     Method  Takes  Returns  Description      the function specified in  command       after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the widget if it was previously hidden    update_command(command)  command (function name)  -  Updates the function to call when the slider value is changed    add_command(command)  command (function name)  -  Sets the function called when the slider value is changed to     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/slider/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    font  string  The font of the text    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Sets the height of the widget    master  App or Box  The container to which this widget belongs    text_size  int  The size of the text    text_color  color  The colour of the text    value  string  The current value of the slider    visible  boolean  If this widget is visible    width  size  Sets the width of the widget",
            "title": "Properties"
        },
        {
            "location": "/slider/#examples",
            "text": "Calling a function when the slider value changes  You can specify a function to call when the slider value changes. Your function  MUST  have a minimum of one parameter as it will automatically receive a string containing the value of the slider (called  slider_value  in the example) when it is called.  This code has a slider and a text box, and the text box updates automatically to display the current value of the slider.   from guizero import App, Slider, TextBox\ndef slider_changed(slider_value):\n    textbox.value = slider_value\n\napp = App()\nslider = Slider(app, command=slider_changed)\ntextbox = TextBox(app)\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/text/",
            "text": "Text\n\n\n(Contains a \ntkinter.Label\n object)\n\n\n__init__(self, master, text=\"\", size=12, color=\"black\", text_color=None, bg=None, font=\"Helvetica\", grid=None, align=None)\n\n\nWhat is it?\n\n\nThe \nText\n object displays non editable text in your app, useful for titles, labels and instructions.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nText\n object like this:\n\n\nfrom guizero import App, Text\napp = App()\ntext = Text(app, text=\"Hello World\")\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nText\n object, you \nmust\n specify a \nmaster\n and you can specify any of the the optional parameters. Specify parameters in the brackets, like this: \ntext = Text(app, text=\"hi\")\n\n\n\n\n\n\n\n\nParameter\n\n\nData type\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ncolor\n\n\ncolor\n\n\nblack\n\n\n-\n\n\nThe colour of the text. Accepts some colour strings (e.g. \nred\n) and colours specified in hex format (e.g. \n#0099ff\n)\n\n\n\n\n\n\nfont\n\n\nstring\n\n\n\"Helvetica\"\n\n\n-\n\n\nThe font face that the text will be displayed in. Availability of fonts depends on which fonts are installed locally.\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nsize\n\n\nint\n\n\n12\n\n\n-\n\n\nThe font size of the text\n\n\n\n\n\n\ntext\n\n\nstring\n\n\n\"\"\n\n\n-\n\n\nThe text you want to display\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be enabled.\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nText\n object..\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\nappend(text)\n\n\ntext (string)\n\n\n-\n\n\nAdds the provided \ntext\n to the end of the current text within the object\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\nclear()\n\n\n-\n\n\n-\n\n\nClears the text\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\ncolor(color)\n\n\ncolor (string)\n\n\n-\n\n\nReplaced by \ntext_color\n property\n\n\n\n\n\n\nfont_face(font)\n\n\nfont (string)\n\n\n-\n\n\nReplaced by \nfont\n property\n\n\n\n\n\n\nfont_size(size)\n\n\nsize (int)\n\n\n-\n\n\nReplaced by \nsize\n property\n\n\n\n\n\n\nget()\n\n\n-\n\n\nstring\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\nset(text)\n\n\ntext (string)\n\n\n-\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSets the height of the widget\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nsize\n\n\nint\n\n\nThe size of the text\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe text\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSets the width of the widget",
            "title": "Text"
        },
        {
            "location": "/text/#text",
            "text": "(Contains a  tkinter.Label  object)  __init__(self, master, text=\"\", size=12, color=\"black\", text_color=None, bg=None, font=\"Helvetica\", grid=None, align=None)",
            "title": "Text"
        },
        {
            "location": "/text/#what-is-it",
            "text": "The  Text  object displays non editable text in your app, useful for titles, labels and instructions.",
            "title": "What is it?"
        },
        {
            "location": "/text/#how-do-i-make-one",
            "text": "Create a  Text  object like this:  from guizero import App, Text\napp = App()\ntext = Text(app, text=\"Hello World\")\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/text/#starting-parameters",
            "text": "When you create a  Text  object, you  must  specify a  master  and you can specify any of the the optional parameters. Specify parameters in the brackets, like this:  text = Text(app, text=\"hi\")     Parameter  Data type  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    color  color  black  -  The colour of the text. Accepts some colour strings (e.g.  red ) and colours specified in hex format (e.g.  #0099ff )    font  string  \"Helvetica\"  -  The font face that the text will be displayed in. Availability of fonts depends on which fonts are installed locally.    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    size  int  12  -  The font size of the text    text  string  \"\"  -  The text you want to display    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  True  No  If the widget should be enabled.",
            "title": "Starting parameters"
        },
        {
            "location": "/text/#methods",
            "text": "You can call the following methods on a  Text  object..     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    append(text)  text (string)  -  Adds the provided  text  to the end of the current text within the object    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    clear()  -  -  Clears the text    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the widget if it was previously hidden    color(color)  color (string)  -  Replaced by  text_color  property    font_face(font)  font (string)  -  Replaced by  font  property    font_size(size)  size (int)  -  Replaced by  size  property    get()  -  string  Replaced by  value  property    set(text)  text (string)  -  Replaced by  value  property     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/text/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    font  string  The font of the text    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Sets the height of the widget    master  App or Box  The container to which this widget belongs    size  int  The size of the text    text_color  color  The colour of the text    value  string  The text    visible  boolean  If this widget is visible    width  size  Sets the width of the widget",
            "title": "Properties"
        },
        {
            "location": "/textbox/",
            "text": "TextBox\n\n\n(Contains a \ntkinter.Entry\n object)\n\n\n__init__(self, master, text=\"\", width=10, grid=None, align=None)\n\n\nWhat is it\n\n\nThe \nTextBox\n object sisplay a text box which the user can type in.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nTextBox\n object like this:\n\n\nfrom guizero import App, TextBox\napp = App()\ninput_box = TextBox(app)\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nTextBox\n object you \nmust\n specify \nmaster\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \ntextbox = TextBox(app, text=\"Please enter some text\")\n\n\n\n\n\n\n\n\nParameter\n\n\nData type\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ntext\n\n\nstring\n\n\n\"\"\n\n\n-\n\n\nAny text you wish to be pre-filled in the text box\n\n\n\n\n\n\nwidth\n\n\nint\n\n\n10\n\n\n-\n\n\nThe width of the text box\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be enabled.\n\n\n\n\n\n\nmultiline\n\n\nboolean\n\n\nFalse\n\n\nNo\n\n\nCreate a multi-line text box.\n\n\n\n\n\n\nscrollbar\n\n\nboolean\n\n\nFalse\n\n\nNo\n\n\nAdd a vertical scrollbar to a multi-line text box\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when the text is changed. This function MUST take either zero or one argument, if the function takes one argument the key which was added to the textbox will be returned.\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on your TextBox object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\nappend(text)\n\n\ntext (string)\n\n\n-\n\n\nAdds the provided \ntext\n to the end of the current text within the text box\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\nclear()\n\n\n-\n\n\n-\n\n\nClears the textbox\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\nupdate_command(command)\n\n\ncommand (function name)\n\n\n-\n\n\nUpdates the function to call when the text is changed.\n\n\n\n\n\n\nget()\n\n\n-\n\n\nstring\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\nset(text)\n\n\ntext (string)\n\n\n-\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe text in the TextBox\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSets the width of the widget\n\n\n\n\n\n\nsize\n\n\nint\n\n\nThe size of the text\n\n\n\n\n\n\ntext_color\n\n\ncolor\n\n\nThe colour of the text\n\n\n\n\n\n\n\n\nExamples\n\n\nCreating a TextBox with default text\n\n\nYou can set the default text in a TextBox when it is created using the \ntext\n parameter:\n\n\nfrom guizero import App, TextBox\napp = App()\ninput_box = TextBox(app, text=\"Type here\")\napp.display()\n\n\n\n\nCreating a multi-line TextBox\n\n\nYou can create a text box which is capable of capturing multiple lines of text by setting the \nmultiline\n parameter to \nTrue\n and giving the textbox a \nheight\n:\n\n\nfrom guizero import App, TextBox\napp = App()\ninput_box = TextBox(app, text=\"Type lines here\", height=10, multiline=True)\napp.display()\n\n\n\n\nMulti-line text boxes can also be given a scrollbar by setting the \nscrollbar\n parameter to \nTrue\n:\n\n\ninput_box = TextBox(app, text=\"Type lines here\", height=10, multiline=True, scrollbar=True)",
            "title": "TextBox"
        },
        {
            "location": "/textbox/#textbox",
            "text": "(Contains a  tkinter.Entry  object)  __init__(self, master, text=\"\", width=10, grid=None, align=None)",
            "title": "TextBox"
        },
        {
            "location": "/textbox/#what-is-it",
            "text": "The  TextBox  object sisplay a text box which the user can type in.",
            "title": "What is it"
        },
        {
            "location": "/textbox/#how-do-i-make-one",
            "text": "Create a  TextBox  object like this:  from guizero import App, TextBox\napp = App()\ninput_box = TextBox(app)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/textbox/#starting-parameters",
            "text": "When you create a  TextBox  object you  must  specify  master  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  textbox = TextBox(app, text=\"Please enter some text\")     Parameter  Data type  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    text  string  \"\"  -  Any text you wish to be pre-filled in the text box    width  int  10  -  The width of the text box    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  True  No  If the widget should be enabled.    multiline  boolean  False  No  Create a multi-line text box.    scrollbar  boolean  False  No  Add a vertical scrollbar to a multi-line text box    command  function name  None  -  The name of a function to call when the text is changed. This function MUST take either zero or one argument, if the function takes one argument the key which was added to the textbox will be returned.",
            "title": "Starting parameters"
        },
        {
            "location": "/textbox/#methods",
            "text": "You can call the following methods on your TextBox object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    append(text)  text (string)  -  Adds the provided  text  to the end of the current text within the text box    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    clear()  -  -  Clears the textbox    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the widget if it was previously hidden    update_command(command)  command (function name)  -  Updates the function to call when the text is changed.    get()  -  string  Replaced by  value  property    set(text)  text (string)  -  Replaced by  value  property     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/textbox/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    enabled  boolean  True  if the widget is enabled    font  string  The font of the text    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    master  App or Box  The container to which this widget belongs    value  string  The text in the TextBox    visible  boolean  If this widget is visible    width  size  Sets the width of the widget    size  int  The size of the text    text_color  color  The colour of the text",
            "title": "Properties"
        },
        {
            "location": "/textbox/#examples",
            "text": "Creating a TextBox with default text  You can set the default text in a TextBox when it is created using the  text  parameter:  from guizero import App, TextBox\napp = App()\ninput_box = TextBox(app, text=\"Type here\")\napp.display()  Creating a multi-line TextBox  You can create a text box which is capable of capturing multiple lines of text by setting the  multiline  parameter to  True  and giving the textbox a  height :  from guizero import App, TextBox\napp = App()\ninput_box = TextBox(app, text=\"Type lines here\", height=10, multiline=True)\napp.display()  Multi-line text boxes can also be given a scrollbar by setting the  scrollbar  parameter to  True :  input_box = TextBox(app, text=\"Type lines here\", height=10, multiline=True, scrollbar=True)",
            "title": "Examples"
        },
        {
            "location": "/waffle/",
            "text": "Waffle\n\n\n(Contains a \ntkinter.Frame\n object)\n\n\n__init__(self, master, height=3, width=3, dim=20, pad=5, color=\"white\", dotty=False, grid=None, align=None, command=None)\n\n\nWhat is it\n\n\nThe \nWaffle\n object display an n*n grid of squares with custom dimensions and padding\n\n\n\n\nHow do I make one?\n\n\nCreate a \nWaffle\n object like this:\n\n\nfrom guizero import App, Waffle\napp = App()\nwaffle = Waffle(app)\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nWaffle\n object you \nmust\n specify \nmaster\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \nwaffle = Waffle(app, height=25)\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ncolor\n\n\ncolor\n\n\n\"white\"\n\n\n-\n\n\nThe default colour of pixels on the waffle\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when the waffle is clicked. This function MUST take either zero of two arguments, if the function takes two arguments the \nx\n and \ny\n co-ordinates of the pixel which was clicked will be given.\n\n\n\n\n\n\ndim\n\n\nint\n\n\n20\n\n\n-\n\n\nHow large one of the pixels on the waffle is\n\n\n\n\n\n\ndotty\n\n\nboolean\n\n\nFalse\n\n\n-\n\n\nWhether the pixels display as dots/circles (True) or squares (False)\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nheight\n\n\nint\n\n\n3\n\n\n-\n\n\nHow many pixels high the waffle is\n\n\n\n\n\n\npad\n\n\nint\n\n\n5\n\n\n-\n\n\nHow much space is between the pixels on the waffle\n\n\n\n\n\n\nwidth\n\n\nint\n\n\n3\n\n\n-\n\n\nHow many pixels wide the waffle is\n\n\n\n\n\n\nremember\n\n\nboolean\n\n\nTrue\n\n\n-\n\n\nNo longer needed - all Waffles will now have a memory.\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be visible.\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the widget should be enabled.\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nNone\n\n\nNo\n\n\nThe background colour of the waffle. Takes a \ncolor\n value.\n\n\n\n\n\n\n\n\nParameters in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nMethods\n\n\nYou can call the following methods on your Waffle object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nget_all()\n\n\n-\n\n\nList\n\n\nReturns the pixel colours in the grid as a 2D list.\n\n\n\n\n\n\nget_pixel(x, y)\n\n\nx (int), y (int)\n\n\nstring\n\n\nReturns the colour of the pixel at the specified coordinates. 0,0 is the top left of the grid.\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\npixel(x, y)\n\n\n(int), y (int)\n\n\nWafflePixel\n\n\nReturns the pixel at the specified coordinates. 0,0 is the top left of the grid. \nWaffle.pixel(x,y)\n is the equivalent of \nWaffle[x,y]\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nset_all(color)\n\n\ncolor (\ncolor\n)\n\n\n-\n\n\nSets all pixels to the specified colour.\n\n\n\n\n\n\nset_pixel(x, y, color)\n\n\nx (int), y (int), color (\ncolor\n)\n\n\n-\n\n\nSets the pixel at the specified coordinates to the specified colour. 0,0 is the top left of the grid.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget\n\n\n\n\n\n\nupdate_command(command)\n\n\ncommand (function name)\n\n\n-\n\n\nUpdates the function to call when the Waffle is clicked\n\n\n\n\n\n\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nThe alignment of this widget within its grid location\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the widget\n\n\n\n\n\n\ncolor\n\n\ncolor\n\n\nThe default colour of pixels on the waffle\n\n\n\n\n\n\ndotty\n\n\nbool\n\n\nIf \nTrue\n the waffle will display circles\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\ngrid\n\n\nList\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid\n\n\n\n\n\n\nheight\n\n\nsize\n\n\nSets the height of the widget\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\npad\n\n\nint\n\n\nThe size of the padding between pixels\n\n\n\n\n\n\npixel_size\n\n\nint\n\n\nThe size of the one pixel\n\n\n\n\n\n\nwidth\n\n\nsize\n\n\nSets the width of the widget\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf this widget is visible\n\n\n\n\n\n\n\n\nExample\n\n\nSet a pixel colour\n\n\nA Waffle can remember the colour of each pixel within it.\n\n\nfrom guizero import App, Waffle\n\napp = App()\n\nmy_waffle = Waffle(app)\nmy_waffle.set_pixel(2, 1, \"red\")\n\n# Your waffle will remember what colour each pixel is\nprint(my_waffle.get_pixel(2,1))\n\n# Even the ones auto-set at the start (which are white by default)\nprint(my_waffle.get_pixel(1,1))\n\napp.display()\n\n\n\n\nWafflePixel\n\n\nA WafflePixel object is returned by \nWaffle.pixel(x,y)\n and \nWaffle[x,y]\n.\n\n\nfrom guizero import App, Waffle\n\napp = App()\n\nmy_waffle = Waffle(app)\nmy_waffle.pixel(x,y).color = \"red\"\nmy_waffle[x,y].dotty = True\n\napp.display()\n\n\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nx\n\n\nint\n\n\nReturns the x position of the pixel on the widget\n\n\n\n\n\n\nx\n\n\nint\n\n\nReturns the y position of the pixel on the widget\n\n\n\n\n\n\ncanvas_x\n\n\nint\n\n\nReturns the x position of the pixel on the canvas\n\n\n\n\n\n\ncanvas_y\n\n\nint\n\n\nReturns the y position of the pixel on the canvas\n\n\n\n\n\n\ncolor\n\n\ncolor\n\n\nSets or returns the color of the pixel\n\n\n\n\n\n\ndotty\n\n\nbool\n\n\nSet to \nTrue\n to make the pixel a circle\n\n\n\n\n\n\nsize\n\n\nint\n\n\nReturns the size of the pixel in \ndisplay\n pixels",
            "title": "Waffle"
        },
        {
            "location": "/waffle/#waffle",
            "text": "(Contains a  tkinter.Frame  object)  __init__(self, master, height=3, width=3, dim=20, pad=5, color=\"white\", dotty=False, grid=None, align=None, command=None)",
            "title": "Waffle"
        },
        {
            "location": "/waffle/#what-is-it",
            "text": "The  Waffle  object display an n*n grid of squares with custom dimensions and padding",
            "title": "What is it"
        },
        {
            "location": "/waffle/#how-do-i-make-one",
            "text": "Create a  Waffle  object like this:  from guizero import App, Waffle\napp = App()\nwaffle = Waffle(app)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/waffle/#starting-parameters",
            "text": "When you create a  Waffle  object you  must  specify  master  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  waffle = Waffle(app, height=25)     Parameter  Takes  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    color  color  \"white\"  -  The default colour of pixels on the waffle    command  function name  None  -  The name of a function to call when the waffle is clicked. This function MUST take either zero of two arguments, if the function takes two arguments the  x  and  y  co-ordinates of the pixel which was clicked will be given.    dim  int  20  -  How large one of the pixels on the waffle is    dotty  boolean  False  -  Whether the pixels display as dots/circles (True) or squares (False)    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    height  int  3  -  How many pixels high the waffle is    pad  int  5  -  How much space is between the pixels on the waffle    width  int  3  -  How many pixels wide the waffle is    remember  boolean  True  -  No longer needed - all Waffles will now have a memory.    visible  boolean  True  No  If the widget should be visible.    enabled  boolean  True  No  If the widget should be enabled.    bg  color  None  No  The background colour of the waffle. Takes a  color  value.     Parameters in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Starting parameters"
        },
        {
            "location": "/waffle/#methods",
            "text": "You can call the following methods on your Waffle object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    get_all()  -  List  Returns the pixel colours in the grid as a 2D list.    get_pixel(x, y)  x (int), y (int)  string  Returns the colour of the pixel at the specified coordinates. 0,0 is the top left of the grid.    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    pixel(x, y)  (int), y (int)  WafflePixel  Returns the pixel at the specified coordinates. 0,0 is the top left of the grid.  Waffle.pixel(x,y)  is the equivalent of  Waffle[x,y]    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    set_all(color)  color ( color )  -  Sets all pixels to the specified colour.    set_pixel(x, y, color)  x (int), y (int), color ( color )  -  Sets the pixel at the specified coordinates to the specified colour. 0,0 is the top left of the grid.    show()  -  -  Displays the widget    update_command(command)  command (function name)  -  Updates the function to call when the Waffle is clicked",
            "title": "Methods"
        },
        {
            "location": "/waffle/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      align  string  The alignment of this widget within its grid location    bg  color  The background colour of the widget    color  color  The default colour of pixels on the waffle    dotty  bool  If  True  the waffle will display circles    enabled  boolean  True  if the widget is enabled    grid  List  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid    height  size  Sets the height of the widget    master  App or Box  The container to which this widget belongs    pad  int  The size of the padding between pixels    pixel_size  int  The size of the one pixel    width  size  Sets the width of the widget    visible  boolean  If this widget is visible",
            "title": "Properties"
        },
        {
            "location": "/waffle/#example",
            "text": "Set a pixel colour  A Waffle can remember the colour of each pixel within it.  from guizero import App, Waffle\n\napp = App()\n\nmy_waffle = Waffle(app)\nmy_waffle.set_pixel(2, 1, \"red\")\n\n# Your waffle will remember what colour each pixel is\nprint(my_waffle.get_pixel(2,1))\n\n# Even the ones auto-set at the start (which are white by default)\nprint(my_waffle.get_pixel(1,1))\n\napp.display()",
            "title": "Example"
        },
        {
            "location": "/waffle/#wafflepixel",
            "text": "A WafflePixel object is returned by  Waffle.pixel(x,y)  and  Waffle[x,y] .  from guizero import App, Waffle\n\napp = App()\n\nmy_waffle = Waffle(app)\nmy_waffle.pixel(x,y).color = \"red\"\nmy_waffle[x,y].dotty = True\n\napp.display()",
            "title": "WafflePixel"
        },
        {
            "location": "/waffle/#properties_1",
            "text": "You can set and get the following properties:     Method  Data type  Description      x  int  Returns the x position of the pixel on the widget    x  int  Returns the y position of the pixel on the widget    canvas_x  int  Returns the x position of the pixel on the canvas    canvas_y  int  Returns the y position of the pixel on the canvas    color  color  Sets or returns the color of the pixel    dotty  bool  Set to  True  to make the pixel a circle    size  int  Returns the size of the pixel in  display  pixels",
            "title": "Properties"
        },
        {
            "location": "/window/",
            "text": "Window\n\n\n(Contains a \ntkinter.TopLevel\n object)\n\n\n__init__(self, master, title=\"guizero\", width=500, height=500, layout=\"auto\", bg=None):\n\n\nWhat is it?\n\n\nA \nWindow\n object is how you create new windows in guizero.\n\n\n\n\nHow do I make one?\n\n\nCreate an \nWindow\n object like this:\n\n\nfrom guizero import App, Window\napp = App()\nwindow = Window(app)\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nWindow\n object you \nmust\n specify a \nmaster\n and you can specify any of the the optional parameters. Specify parameters in the brackets like this: \nwindow = Window(app, bg=\"red\", height=200)\n\n\n\n\n\n\n\n\nParameter\n\n\nData type\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp\n\n\n-\n\n\nYes\n\n\nThe app to which the window belongs\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nNone\n\n\nNo\n\n\nThe background colour of the window. Takes a \ncolor\n value.\n\n\n\n\n\n\nheight\n\n\nint\n\n\n500\n\n\nNo\n\n\nThe height of the window in pixels.\n\n\n\n\n\n\nlayout\n\n\nstring\n\n\n\"auto\"\n\n\nNo\n\n\nWhether widgets pack themselves (\n\"auto\"\n) or you specify their position on a grid (\n\"grid\"\n)\n\n\n\n\n\n\ntitle\n\n\nstring\n\n\n\"guizero\"\n\n\nNo\n\n\nThe title displayed in the bar at the top of the window.\n\n\n\n\n\n\nwidth\n\n\nint\n\n\n500\n\n\nNo\n\n\nThe width of the window in pixels.\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nTrue\n\n\nNo\n\n\nIf the window should be visible.\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nWindow\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the window\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the window\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the window from view.\n\n\n\n\n\n\non_close(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCalls the given function when the user tries to close the window.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow(wait = False)\n\n\n-\n\n\n-\n\n\nDisplays the window if it was previously hidden\n\n\n\n\n\n\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbg\n\n\ncolor\n\n\nThe background colour of the window\n\n\n\n\n\n\nheight\n\n\nint\n\n\nThe height of the window\n\n\n\n\n\n\nlayout\n\n\nstring\n\n\nThe layout being used by the Window (\n\"auto\"\n) or (\n\"grid\"\n)\n\n\n\n\n\n\ntitle\n\n\nstring\n\n\nThe title of the window\n\n\n\n\n\n\nvisible\n\n\nboolean\n\n\nIf the window is visible\n\n\n\n\n\n\nwidth\n\n\nint\n\n\nThe width of the window\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nWindow\n object is called \nwindow\n you would write \nwindow.title\n.\n\n\nYou can \nset\n the property (for example \nwindow.title = \"Hello world\"\n) or \nget\n the value of the property to use (for example \nprint(window.title)\n).\n\n\nExamples\n\n\nCreating an App object\n\n\nCreate an \nWindow\n object by calling the \nWindow()\n constructor. You should give the object a name so you can refer to it later - in this case we have called it \nwindow\n. It is best to keep the name you give to your \nWindow\n object quite short, as you will have to use it to tell other widgets where they should be stored.\n\n\nfrom guizero import App, Window\napp = App(title=\"My app\", height=300, width=200)\nwindow = Window(title = \"2nd Window\", height=300, width=200)\napp.display()\n\n\n\n\nShowing and hiding a Window\n\n\nWindow\n objects can be shown and hidden using the \nshow()\n and \nhide()\n methods:\n\n\nfrom guizero import App, Window, PushButton\n\ndef open_window():\n    window_2.show()\n\napp = App(title=\"My app\", height=300, width=200)\nwindow = Window(title = \"2nd Window\", height=300, width=200)\nwindow.hide()\n\nopen_button(app, text=\"open 2nd window\", command=open_window)\n\napp.display()\n\n\n\n\nIf you want a \nWindow\n to become the main window and stop all other windows responding until it is closed you can set the optional \nwait\n parameter to \nTrue\n when using \nshow\n:\n\n\ndef open_window():\n    window_2.show(wait = True)",
            "title": "Window"
        },
        {
            "location": "/window/#window",
            "text": "(Contains a  tkinter.TopLevel  object)  __init__(self, master, title=\"guizero\", width=500, height=500, layout=\"auto\", bg=None):",
            "title": "Window"
        },
        {
            "location": "/window/#what-is-it",
            "text": "A  Window  object is how you create new windows in guizero.",
            "title": "What is it?"
        },
        {
            "location": "/window/#how-do-i-make-one",
            "text": "Create an  Window  object like this:  from guizero import App, Window\napp = App()\nwindow = Window(app)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/window/#starting-parameters",
            "text": "When you create a  Window  object you  must  specify a  master  and you can specify any of the the optional parameters. Specify parameters in the brackets like this:  window = Window(app, bg=\"red\", height=200)     Parameter  Data type  Default  Compulsory  Description      master  App  -  Yes  The app to which the window belongs    bg  color  None  No  The background colour of the window. Takes a  color  value.    height  int  500  No  The height of the window in pixels.    layout  string  \"auto\"  No  Whether widgets pack themselves ( \"auto\" ) or you specify their position on a grid ( \"grid\" )    title  string  \"guizero\"  No  The title displayed in the bar at the top of the window.    width  int  500  No  The width of the window in pixels.    visible  boolean  True  No  If the window should be visible.",
            "title": "Starting parameters"
        },
        {
            "location": "/window/#methods",
            "text": "You can call the following methods on a  Window  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the window    focus()  -  -  Gives focus to the window    hide()  -  -  Hides the window from view.    on_close(command)  command (function name)  -  Calls the given function when the user tries to close the window.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show(wait = False)  -  -  Displays the window if it was previously hidden",
            "title": "Methods"
        },
        {
            "location": "/window/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      bg  color  The background colour of the window    height  int  The height of the window    layout  string  The layout being used by the Window ( \"auto\" ) or ( \"grid\" )    title  string  The title of the window    visible  boolean  If the window is visible    width  int  The width of the window     Refer to a property as  <name of widget>.property . For example, if your  Window  object is called  window  you would write  window.title .  You can  set  the property (for example  window.title = \"Hello world\" ) or  get  the value of the property to use (for example  print(window.title) ).",
            "title": "Properties"
        },
        {
            "location": "/window/#examples",
            "text": "Creating an App object  Create an  Window  object by calling the  Window()  constructor. You should give the object a name so you can refer to it later - in this case we have called it  window . It is best to keep the name you give to your  Window  object quite short, as you will have to use it to tell other widgets where they should be stored.  from guizero import App, Window\napp = App(title=\"My app\", height=300, width=200)\nwindow = Window(title = \"2nd Window\", height=300, width=200)\napp.display()  Showing and hiding a Window  Window  objects can be shown and hidden using the  show()  and  hide()  methods:  from guizero import App, Window, PushButton\n\ndef open_window():\n    window_2.show()\n\napp = App(title=\"My app\", height=300, width=200)\nwindow = Window(title = \"2nd Window\", height=300, width=200)\nwindow.hide()\n\nopen_button(app, text=\"open 2nd window\", command=open_window)\n\napp.display()  If you want a  Window  to become the main window and stop all other windows responding until it is closed you can set the optional  wait  parameter to  True  when using  show :  def open_window():\n    window_2.show(wait = True)",
            "title": "Examples"
        },
        {
            "location": "/contributing/",
            "text": "Contributing\n\n\nContibutions are very welcome; be that changes, bug fixing, issue resolution or support.\n\n\nIssues\n\n\nAll issues should be raise on \ngithub.com/lawsie/guizero/issues\n\n\nCode\n\n\nWhen providing code changes please:\n\n\n\n\nuse the \ndev\n branch as the base for all changes\n\n\ncreate a single pull requests for each fix / addition\n\n\nfollow the existing coding style\n\n\nprovide documentation for all changes as markdown in \n/docs-src\n\n\nprovide tests for all changes in \n/test",
            "title": "Notes"
        },
        {
            "location": "/contributing/#contributing",
            "text": "Contibutions are very welcome; be that changes, bug fixing, issue resolution or support.",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#issues",
            "text": "All issues should be raise on  github.com/lawsie/guizero/issues",
            "title": "Issues"
        },
        {
            "location": "/contributing/#code",
            "text": "When providing code changes please:   use the  dev  branch as the base for all changes  create a single pull requests for each fix / addition  follow the existing coding style  provide documentation for all changes as markdown in  /docs-src  provide tests for all changes in  /test",
            "title": "Code"
        },
        {
            "location": "/development/",
            "text": "Development\n\n\nNotes on how to develop guizero (on Windows).\n\n\nInstall Pre-requisites\n\n\npip install mkdocs wheel twine virtualenv pytest pillow\n\n\n\n\nPython library\n\n\nCreate a virtual environment (not essential, but a good idea!):\n\n\nmkdir guizero-[versionno]\nvirtualenv guizero-[versionno]\ncd guizero-[versionno]\n\n\n\n\nActivate your virtual environment:\n\n\nScripts\\activate\n\n\n\n\nCheckout and install guizero for development:\n\n\ngit clone https://github.com/lawsie/guizero\ncd guizero\ngit checkout dev\npython setup.py develop\n\n\n\n\nWhen you have finished your development, deactivate your virtual environment:\n\n\nScripts\\deactivate\n\n\n\n\nTests\n\n\nTo run the automated tests:\n\n\ncd guizero\\test\npytest -v \n\n\n\n\nNote - tkinter can error when running the tests usually when the interpreter doesn't start properly, it doesnt seem to like being initialised and destroyed hundreds of times, I suspect a file locking issue as you dont see the problem on Linux. So sometimes you might get a test fail with an error like \nThis probably means that tk wasn't installed properly.\n.\n\n\nJust give it a re-run!\n\n\nDocuments\n\n\nTest documents by serving up MkDocs:\n\n\ncd guizero\\docs-src\nmkdocs serve\n\n\n\n\nOpen \nhttp://127.0.0.1:8000/",
            "title": "Developing"
        },
        {
            "location": "/development/#development",
            "text": "Notes on how to develop guizero (on Windows).",
            "title": "Development"
        },
        {
            "location": "/development/#install-pre-requisites",
            "text": "pip install mkdocs wheel twine virtualenv pytest pillow",
            "title": "Install Pre-requisites"
        },
        {
            "location": "/development/#python-library",
            "text": "Create a virtual environment (not essential, but a good idea!):  mkdir guizero-[versionno]\nvirtualenv guizero-[versionno]\ncd guizero-[versionno]  Activate your virtual environment:  Scripts\\activate  Checkout and install guizero for development:  git clone https://github.com/lawsie/guizero\ncd guizero\ngit checkout dev\npython setup.py develop  When you have finished your development, deactivate your virtual environment:  Scripts\\deactivate",
            "title": "Python library"
        },
        {
            "location": "/development/#tests",
            "text": "To run the automated tests:  cd guizero\\test\npytest -v   Note - tkinter can error when running the tests usually when the interpreter doesn't start properly, it doesnt seem to like being initialised and destroyed hundreds of times, I suspect a file locking issue as you dont see the problem on Linux. So sometimes you might get a test fail with an error like  This probably means that tk wasn't installed properly. .  Just give it a re-run!",
            "title": "Tests"
        },
        {
            "location": "/development/#documents",
            "text": "Test documents by serving up MkDocs:  cd guizero\\docs-src\nmkdocs serve  Open  http://127.0.0.1:8000/",
            "title": "Documents"
        },
        {
            "location": "/deployment/",
            "text": "Deploy\n\n\nNotes on how to deploy guizero (on Windows).\n\n\nPrepare\n\n\n\n\nUpdate version number in \nsetup.py\n\n\nUpdate version number in \nREADME.md\n\n\nUpdate release date in \nREADME.md\n\n\nUpdate version number in \ndocs-src\\docs\\about.md\n\n\nUpdate \nchangelog\n in debian packages\n\n\nUpdate \nchangelog.md\n in docs\n\n\n\n\nPython library\n\n\nInstall locally:\n\n\ncd guizero\npython setup.py install\n\n\n\n\nBuild for deployment:\n\n\ncd guizero\npython setup.py sdist\npython setup.py bdist_wheel\n\n\n\n\nCreate .pypirc credentials:\n\n\ncd %HOME%\nnotepad .pypirc\n\n\n\n\n[distutils]\nindex-servers =\n    pypi\n\n[pypi]\nusername:\npassword:\n\n\n\n\nUpload to pypi:\n\n\ncd guizero\ntwine upload dist/* --skip-existing\n\n\n\n\nDocuments\n\n\nBuild:\n\n\ncd guizero/docs-src\nmkdocs build\n\n\n\n\nCopy to \ndocs\n:\n\n\ncd guizero\nxcopy docs-src\\site\\* docs /E",
            "title": "Deploying"
        },
        {
            "location": "/deployment/#deploy",
            "text": "Notes on how to deploy guizero (on Windows).",
            "title": "Deploy"
        },
        {
            "location": "/deployment/#prepare",
            "text": "Update version number in  setup.py  Update version number in  README.md  Update release date in  README.md  Update version number in  docs-src\\docs\\about.md  Update  changelog  in debian packages  Update  changelog.md  in docs",
            "title": "Prepare"
        },
        {
            "location": "/deployment/#python-library",
            "text": "Install locally:  cd guizero\npython setup.py install  Build for deployment:  cd guizero\npython setup.py sdist\npython setup.py bdist_wheel  Create .pypirc credentials:  cd %HOME%\nnotepad .pypirc  [distutils]\nindex-servers =\n    pypi\n\n[pypi]\nusername:\npassword:  Upload to pypi:  cd guizero\ntwine upload dist/* --skip-existing",
            "title": "Python library"
        },
        {
            "location": "/deployment/#documents",
            "text": "Build:  cd guizero/docs-src\nmkdocs build  Copy to  docs :  cd guizero\nxcopy docs-src\\site\\* docs /E",
            "title": "Documents"
        },
        {
            "location": "/changelog/",
            "text": "guizero\n\n\n0.5.0 - 2018-04-10\n\n\n\n\nv0.5.0 includes significant refactoring of the guizero code base and introduces many new features\n\n\nNew image functionality introduced when PIL is installed:\n\n\nimages can be passed as \nTk.PhotoImage\n or \nPIL.Image\n objects as well as file paths\n\n\nmore images types are supported\n\n\nanimated images (gifs) are supported\n\n\nimages are scaled when the size is changed\n\n\n\n\n\n\nButtonGroup\n - \nselected\n is now optional, \nenabled\n properties now supported, \nvalue_text\n fixed\n\n\nFixed multiple \nApp\n bug\n\n\nCreated \nWindow\n class to support multi-window applications\n\n\nAdded \nmultiline\n and \nscrollbar\n functionality to \nTextBox\n\n\nRefactored guizero to introduce a class hierarchy making guizero wide code changes easier to implement\n\n\nAdded the following events to all widgets, this should be considered experimental in this release:\n\n\nwhen_clicked\n\n\nwhen_left_button_pressed\n\n\nwhen_left_button_released\n\n\nwhen_right_button_pressed\n\n\nwhen_right_button_released\n\n\nwhen_key_pressed\n\n\nwhen_key_released\n\n\nwhen_mouse_enters\n\n\nwhen_mouse_leaves\n\n\nwhen_mouse_dragged\n\n\n\n\n\n\nVarious minor bug fixes\n\n\nAutomated tests have been introduced\n\n\ncontributors to this release \nmartinohanlon\n, \nscotty3785\n, \nIDF31\n, \ndrussell1974\n  - ta very much :)\n\n\n\n\n0.4.5 - 2018-03-04\n\n\n\n\ncolors can now be specified as either \n\"red\"\n, \n\"#ffffff\"\n, or \n(red, green, blue)\n \n\n\nchange \nPicture\n \nimage\n startup parameter to be optional\n\n\nupdated \nPicture\n and \nPushButton\n errors and docs to show that PNG and GIF images can be used in Windows & Linux\n\n\nrefactored \nWaffle\n resolving bugs that setting properties didnt change its appearance\n\n\nchanged waffle so you can reference a pixel using \nwaffle[x,y]\n\n\nadded \ntext_color\n, \ntext_size\n and \nfont\n properties to \nSlider\n\n\nadded \nwidth\n and \nheight\n properties to:\n\n\nBox\n\n\nButtonGroup\n\n\nCheckBox\n\n\nCombo\n\n\nPicture\n\n\nSlider\n\n\nText\n\n\n\n\n\n\nadded \nwidth\n property to:\n\n\nTextBox\n\n\n\n\n\n\ncontributors to this release \nCoal0\n, \nmartinohanlon\n, \nscotty3785\n - :)\n\n\n\n\n0.4.4 - 2018-02-12\n\n\n\n\nmade \nPushButton\n \ncommand\n optional\n\n\nCombo\n command functions can now have 0 arguments\n\n\nWaffle\n command functions can now have 0 arguments\n\n\nrefactored command functions and added \nupdate_command\n to: \n\n\nButtonGroup\n\n\nCheckBox\n\n\nCombo\n\n\nPushButton\n\n\nSlider\n\n\nWaffle\n\n\n\n\n\n\nrefactored \ntext_color\n, \ntext_size\n and \nfont\n properties and added them to:\n\n\nButtonGroup\n\n\nCombo\n\n\nCheckBox\n\n\nPushButton\n\n\nText\n\n\nTextBox\n\n\n\n\n\n\nrefactored \nbg\n (background) and added to:\n\n\nBox\n\n\nButtonGroup\n\n\nCheckBox\n\n\nCombo\n\n\nPicture\n\n\nPushButton\n\n\nSlider\n\n\nText\n\n\nTextBox\n\n\n\n\n\n\ncontributors to this release \nm4ddav3\n, \nCoal0\n, \nlawsie\n, \nmartinohanlon\n - :)\n\n\n\n\n0.4.3 - 2018-01-10\n\n\nMinor features, bug fixes and internal refactoring\n\n\n\n\nadded \nxspan\n, \nyspan\n to grid layout (Credit: \npenguintutor\n)\n\n\nfixed \nshow()\n for widgets in a grid layout\n\n\nadded \nmaster\n, \ngrid\n, \nalign\n and \nvisible\n properties to widgets\n\n\nadded \nlayout\n property to containers\n\n\nfixed \nWaffle\n \nheight\n (Credit: \nscotty3785\n)\n\n\nminor doc updates\n\n\n0.4.2 was never released due to some pypi / wheel problems\n\n\n\n\n0.4.1 - 2017-12-28\n\n\nBug fixes and deployment test\n\n\n\n\nPushButton bug fixes\n\n\nadded \nenabled\n property to widgets which support \nEnable\n / \nDisable\n\n\ndocumentation tidy up\n\n\nadded build notes to documentation\n\n\n\n\n0.4 - 2017-12-19\n\n\nThank you to everyone who has taken time to contribute code, suggest helpful improvements and report their use of the library. I am extremely grateful to the following people who have contributed pull requests since the last version:\n\nbcroston\n, \nbennuttall\n, \nCoal0\n,  \nmartinohanlon\n and  \nscotty3785\n\n\nI am also very pleased to announce that \nmartinohanlon\n has very kindly agreed to maintain guizero whilst I am on maternity leave, beginning December 2017.\n\n\nGeneral changes:\n\n\n\n\nAll classes rewritten with internal Tk objects rather than extending the Tk object, meaning you can access all Tk functionality as \nObject.tk.tkmethod()\n (Credit for idea: \nbennuttall\n)\n\n\nImproved use of library with tab complete editors (e.g. ipython) \u2013 only the guizero properties and methods are listed so the list is shorter and more friendly. (Credit for idea: \nbennuttall\n)\n\n\n[Bug fix] Grid layout now lays items out properly. Previously the x and y axes were flipped. (Whoops!) \nThis fix will cause apps with a grid layout to look different, but now behave correctly. You may need to update old code as a result of this change.\n\n\nAll classes now inherit from mixins, adding 9 new common methods usable on most widgets - \nafter()\n, \ncancel()\n, \ndestroy()\n, \ndisable()\n, \nenable()\n, \nfocus()\n, \nhide()\n, \nshow()\n, \nrepeat()\n,  (Credit: \nCoal0\n and \nmartinohanlon\n)\n\n\nThe new \nrepeat()\n method allows you to easily specify a repeated callback to a function, making it extremely easy to perform repetitive actions such as updating the GUI based on readings from a sensor.\n\n\nDocumentation and examples have been improved and updated\n\n\n\n\nApp:\n\n\n\n\nNew constructor argument \nbg\n replaces deprecated \nbgcolor\n argument. If both are specified, \nbg\n overrides \nbgcolor\n.\n\n\nset_title()\n and \nbgcolor()\n methods are now deprecated and have been replaced by \ntitle\n and \nbg\n properties\n\n\nNew additional properties \nwidth\n and \nheight\n\n\n\n\nButtonGroup:\n\n\n\n\nget()\n and \nset()\n methods are now deprecated and have been replaced by the \nvalue\n property\n\n\nNew \nvalue_text\n property to get the text associated with the selected option\n\n\n\n\nCheckBox:\n\n\n\n\nget_text()\n, \nget_value()\n and \nchange_text()\n methods are now deprecated and have been replaced by the \nvalue\n and \ntext\n properties\n\n\nNew \ntoggle()\n method added\n\n\n\n\nCombo:\n\n\n\n\nget()\n and \nset()\n methods are now deprecated and have been replaced by the \nvalue\n property\n\n\n[Bug fix] \nset_default()\n now correctly resets the combo back to its originally specified value, whether this was the first option or a specified option\n\n\n\n\nPicture:\n\n\n\n\nset()\n method is now deprecated and has been replaced by the \nvalue\n property\n\n\n\n\nPushButton:\n\n\n\n\nset_text()\n method is now deprecated and has been replaced by the \ntext\n property\n\n\nNew properties for \ntext_color\n, \nbg\n, \nfont\n, \ntext_size\n, \nheight\n and \nwidth\n \u2013 make your buttons look pretty!\n\n\nFind out whether a button is pressed (1) or released (0) with the new \nvalue\n property\n\n\nNew \nicon()\n method to set the icon of a button after it is created\n\n\ntoggle_state()\n method deprecated and renamed to \ntoggle()\n for consistency\n\n\n\n\nSlider:\n\n\n\n\nNew \nvalue\n property for getting and setting the value of the slider\n\n\n\n\nText:\n\n\n\n\nNew constructor arguments \ntext_color\n and \nbg\n\n\ncolor\n constructor argument now deprecated and replaced by \ntext_color\n. If both are specified, \ntext_color\n overrides \ncolor\n.\n\n\nget()\n, \nset()\n, \ncolor()\n, \nfont_face()\n and \nfont_size()\n methods are now deprecated, replaced by properties \nvalue\n, \ntext_color\n, \nbg\n, \nfont\n and \nsize\n\n\n\n\nTextBox:\n\n\n\n\nget()\n and \nset()\n methods now deprecated and replaced by \nvalue\n property\n\n\n\n\nWaffle:\n\n\n\n\nAll waffles will now have a memory. The \nremember\n constructor argument remains for backwards compatibility only \nand will be removed in a future release\n.\n\n\nYou can now click on a Waffle, and specify a command to run when the Waffle is clicked on. The function given as the command should take two arguments as it will be passed the x, y coordinates of the pixel that was clicked. (Credit: \nscotty3785\n)\n\n\nChanged internal implementation of the Waffle so it should now be able to redraw more efficiently. (Credit: \nscotty3785\n)",
            "title": "Change log"
        },
        {
            "location": "/changelog/#guizero",
            "text": "",
            "title": "guizero"
        },
        {
            "location": "/changelog/#050-2018-04-10",
            "text": "v0.5.0 includes significant refactoring of the guizero code base and introduces many new features  New image functionality introduced when PIL is installed:  images can be passed as  Tk.PhotoImage  or  PIL.Image  objects as well as file paths  more images types are supported  animated images (gifs) are supported  images are scaled when the size is changed    ButtonGroup  -  selected  is now optional,  enabled  properties now supported,  value_text  fixed  Fixed multiple  App  bug  Created  Window  class to support multi-window applications  Added  multiline  and  scrollbar  functionality to  TextBox  Refactored guizero to introduce a class hierarchy making guizero wide code changes easier to implement  Added the following events to all widgets, this should be considered experimental in this release:  when_clicked  when_left_button_pressed  when_left_button_released  when_right_button_pressed  when_right_button_released  when_key_pressed  when_key_released  when_mouse_enters  when_mouse_leaves  when_mouse_dragged    Various minor bug fixes  Automated tests have been introduced  contributors to this release  martinohanlon ,  scotty3785 ,  IDF31 ,  drussell1974   - ta very much :)",
            "title": "0.5.0 - 2018-04-10"
        },
        {
            "location": "/changelog/#045-2018-03-04",
            "text": "colors can now be specified as either  \"red\" ,  \"#ffffff\" , or  (red, green, blue)    change  Picture   image  startup parameter to be optional  updated  Picture  and  PushButton  errors and docs to show that PNG and GIF images can be used in Windows & Linux  refactored  Waffle  resolving bugs that setting properties didnt change its appearance  changed waffle so you can reference a pixel using  waffle[x,y]  added  text_color ,  text_size  and  font  properties to  Slider  added  width  and  height  properties to:  Box  ButtonGroup  CheckBox  Combo  Picture  Slider  Text    added  width  property to:  TextBox    contributors to this release  Coal0 ,  martinohanlon ,  scotty3785  - :)",
            "title": "0.4.5 - 2018-03-04"
        },
        {
            "location": "/changelog/#044-2018-02-12",
            "text": "made  PushButton   command  optional  Combo  command functions can now have 0 arguments  Waffle  command functions can now have 0 arguments  refactored command functions and added  update_command  to:   ButtonGroup  CheckBox  Combo  PushButton  Slider  Waffle    refactored  text_color ,  text_size  and  font  properties and added them to:  ButtonGroup  Combo  CheckBox  PushButton  Text  TextBox    refactored  bg  (background) and added to:  Box  ButtonGroup  CheckBox  Combo  Picture  PushButton  Slider  Text  TextBox    contributors to this release  m4ddav3 ,  Coal0 ,  lawsie ,  martinohanlon  - :)",
            "title": "0.4.4 - 2018-02-12"
        },
        {
            "location": "/changelog/#043-2018-01-10",
            "text": "Minor features, bug fixes and internal refactoring   added  xspan ,  yspan  to grid layout (Credit:  penguintutor )  fixed  show()  for widgets in a grid layout  added  master ,  grid ,  align  and  visible  properties to widgets  added  layout  property to containers  fixed  Waffle   height  (Credit:  scotty3785 )  minor doc updates  0.4.2 was never released due to some pypi / wheel problems",
            "title": "0.4.3 - 2018-01-10"
        },
        {
            "location": "/changelog/#041-2017-12-28",
            "text": "Bug fixes and deployment test   PushButton bug fixes  added  enabled  property to widgets which support  Enable  /  Disable  documentation tidy up  added build notes to documentation",
            "title": "0.4.1 - 2017-12-28"
        },
        {
            "location": "/changelog/#04-2017-12-19",
            "text": "Thank you to everyone who has taken time to contribute code, suggest helpful improvements and report their use of the library. I am extremely grateful to the following people who have contributed pull requests since the last version: bcroston ,  bennuttall ,  Coal0 ,   martinohanlon  and   scotty3785  I am also very pleased to announce that  martinohanlon  has very kindly agreed to maintain guizero whilst I am on maternity leave, beginning December 2017.  General changes:   All classes rewritten with internal Tk objects rather than extending the Tk object, meaning you can access all Tk functionality as  Object.tk.tkmethod()  (Credit for idea:  bennuttall )  Improved use of library with tab complete editors (e.g. ipython) \u2013 only the guizero properties and methods are listed so the list is shorter and more friendly. (Credit for idea:  bennuttall )  [Bug fix] Grid layout now lays items out properly. Previously the x and y axes were flipped. (Whoops!)  This fix will cause apps with a grid layout to look different, but now behave correctly. You may need to update old code as a result of this change.  All classes now inherit from mixins, adding 9 new common methods usable on most widgets -  after() ,  cancel() ,  destroy() ,  disable() ,  enable() ,  focus() ,  hide() ,  show() ,  repeat() ,  (Credit:  Coal0  and  martinohanlon )  The new  repeat()  method allows you to easily specify a repeated callback to a function, making it extremely easy to perform repetitive actions such as updating the GUI based on readings from a sensor.  Documentation and examples have been improved and updated   App:   New constructor argument  bg  replaces deprecated  bgcolor  argument. If both are specified,  bg  overrides  bgcolor .  set_title()  and  bgcolor()  methods are now deprecated and have been replaced by  title  and  bg  properties  New additional properties  width  and  height   ButtonGroup:   get()  and  set()  methods are now deprecated and have been replaced by the  value  property  New  value_text  property to get the text associated with the selected option   CheckBox:   get_text() ,  get_value()  and  change_text()  methods are now deprecated and have been replaced by the  value  and  text  properties  New  toggle()  method added   Combo:   get()  and  set()  methods are now deprecated and have been replaced by the  value  property  [Bug fix]  set_default()  now correctly resets the combo back to its originally specified value, whether this was the first option or a specified option   Picture:   set()  method is now deprecated and has been replaced by the  value  property   PushButton:   set_text()  method is now deprecated and has been replaced by the  text  property  New properties for  text_color ,  bg ,  font ,  text_size ,  height  and  width  \u2013 make your buttons look pretty!  Find out whether a button is pressed (1) or released (0) with the new  value  property  New  icon()  method to set the icon of a button after it is created  toggle_state()  method deprecated and renamed to  toggle()  for consistency   Slider:   New  value  property for getting and setting the value of the slider   Text:   New constructor arguments  text_color  and  bg  color  constructor argument now deprecated and replaced by  text_color . If both are specified,  text_color  overrides  color .  get() ,  set() ,  color() ,  font_face()  and  font_size()  methods are now deprecated, replaced by properties  value ,  text_color ,  bg ,  font  and  size   TextBox:   get()  and  set()  methods now deprecated and replaced by  value  property   Waffle:   All waffles will now have a memory. The  remember  constructor argument remains for backwards compatibility only  and will be removed in a future release .  You can now click on a Waffle, and specify a command to run when the Waffle is clicked on. The function given as the command should take two arguments as it will be passed the x, y coordinates of the pixel that was clicked. (Credit:  scotty3785 )  Changed internal implementation of the Waffle so it should now be able to redraw more efficiently. (Credit:  scotty3785 )",
            "title": "0.4 - 2017-12-19"
        }
    ]
}