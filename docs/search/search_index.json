{
    "docs": [
        {
            "location": "/about/",
            "text": "About\n\n\nWhat is guizero?\n\n\n\n\nIt is a Python 3 library for creating simple GUIs\n\n\nIt is a wrapper for the standard Tkinter library (included by default when Python is installed)\n\n\n\n\nAims\n\n\nThe aim of guizero is to make the process of creating simple GUIs quick, accessible and understandable for children.\n\n\n\n\nWorks with standard Python Tkinter GUI library (and no need to install other libraries)\n\n\nAbstracts away details children find difficult to understand (such as Tkinter StringVar() objects)\n\n\nAccessible widget naming system to help children to build up a mental model\n\n\nFlexible enough to be used for projects up to A-Level standard, yet accessible to primary school children\n\n\nComprehensive and accessible documentation with examples\n\n\nGenerates helpful additional error messages\n\n\n\n\nVersion\n\n\nguizero is currently version 0.4\n\n\nThere may be bugs and features may change and be updated.",
            "title": "About"
        },
        {
            "location": "/about/#about",
            "text": "",
            "title": "About"
        },
        {
            "location": "/about/#what-is-guizero",
            "text": "It is a Python 3 library for creating simple GUIs  It is a wrapper for the standard Tkinter library (included by default when Python is installed)",
            "title": "What is guizero?"
        },
        {
            "location": "/about/#aims",
            "text": "The aim of guizero is to make the process of creating simple GUIs quick, accessible and understandable for children.   Works with standard Python Tkinter GUI library (and no need to install other libraries)  Abstracts away details children find difficult to understand (such as Tkinter StringVar() objects)  Accessible widget naming system to help children to build up a mental model  Flexible enough to be used for projects up to A-Level standard, yet accessible to primary school children  Comprehensive and accessible documentation with examples  Generates helpful additional error messages",
            "title": "Aims"
        },
        {
            "location": "/about/#version",
            "text": "guizero is currently version 0.4  There may be bugs and features may change and be updated.",
            "title": "Version"
        },
        {
            "location": "/",
            "text": "Installation\n\n\nguizero is designed to allow children to quickly and easily create GUIs for their programs.\n\n\nIf you can download and unzip a file, you can \ninstall guizero\n - \nno special permissions or administrator rights are required\n.\n\n\nIf you have administrator rights and are connected to the internet, you can use \npip to quickly install guizero\n.\n\n\nguizero only requires \ntkinter\n to be installed, which is included with a standard Python installation on all platforms except Linux.\n\n\nEasy installation\n\n\n\n\n\n\nGo to the \nGithub repo\n for guizero\n\n\n\n\n\n\nClick the green \"Clone or download\" button and then \"Download ZIP\"\n\n\n\n\n\n\n\n\nUnzip the file\n\n\n\n\n\n\nOpen the \nguizero-master\n folder, then copy the \nguizero\n folder and paste it into your home directory\n\n\n\n\n\n\n\n\nThat's it! When you write your guizero code, make sure you save it into your home directory.\n\n\n\n\n\n\nInstall using pip\n\n\nWindows\n\n\n\n\nMake sure you have \npip\n installed.\n\n\nOpen a command prompt\n\n\nType \npip install guizero\n and press Enter\n\n\n\n\nRaspberry Pi\n\n\n\n\nOpen a terminal window\n\n\nType \nsudo pip3 install guizero\n and press Enter\n\n\n\n\nOn Mac\n\n\n\n\n\n\nOpen a terminal (you can search for it in the Launch Pad)\n\n\n\n\n\n\n\n\nType \nsudo pip3 install guizero\n\n\n\n\n\n\n\n\nOn Linux\n\n\n\n\nOpen a terminal\n\n\nInstall \ntkinter\n using your distribution's package manager, e.g. \nsudo apt install python3-tk\n\n\nInstall guizero using pip by typing \nsudo pip3 install guizero",
            "title": "Installation"
        },
        {
            "location": "/#installation",
            "text": "guizero is designed to allow children to quickly and easily create GUIs for their programs.  If you can download and unzip a file, you can  install guizero  -  no special permissions or administrator rights are required .  If you have administrator rights and are connected to the internet, you can use  pip to quickly install guizero .  guizero only requires  tkinter  to be installed, which is included with a standard Python installation on all platforms except Linux.",
            "title": "Installation"
        },
        {
            "location": "/#easy-installation",
            "text": "Go to the  Github repo  for guizero    Click the green \"Clone or download\" button and then \"Download ZIP\"     Unzip the file    Open the  guizero-master  folder, then copy the  guizero  folder and paste it into your home directory     That's it! When you write your guizero code, make sure you save it into your home directory.",
            "title": "Easy installation"
        },
        {
            "location": "/#install-using-pip",
            "text": "",
            "title": "Install using pip"
        },
        {
            "location": "/#windows",
            "text": "Make sure you have  pip  installed.  Open a command prompt  Type  pip install guizero  and press Enter",
            "title": "Windows"
        },
        {
            "location": "/#raspberry-pi",
            "text": "Open a terminal window  Type  sudo pip3 install guizero  and press Enter",
            "title": "Raspberry Pi"
        },
        {
            "location": "/#on-mac",
            "text": "Open a terminal (you can search for it in the Launch Pad)     Type  sudo pip3 install guizero",
            "title": "On Mac"
        },
        {
            "location": "/#on-linux",
            "text": "Open a terminal  Install  tkinter  using your distribution's package manager, e.g.  sudo apt install python3-tk  Install guizero using pip by typing  sudo pip3 install guizero",
            "title": "On Linux"
        },
        {
            "location": "/start/",
            "text": "Getting Started\n\n\nAt the start of every guizero program, choose the widgets you need from the guizero library and import them:\n\n\nfrom guizero import App, PushButton, Slider\n\n\n\n\nYou only need to import each widget once, and then you can use it in your program as many times as you like.\n\n\nHello World\n\n\nAll guizero projects begin with a main window which is called an \nApp\n. At the end of every guizero program you must tell the program to display the app you have just created.\n\n\nLet's create an app window with the title \"Hello world\":\n\n\nfrom guizero import App\napp = App(title=\"Hello world\")\napp.display()\n\n\n\n\nSave and run the code - you've created your first guizero app!\n\n\nAdding widgets\n\n\nWidgets are the things which appear on the GUI, such as text boxes, buttons, sliders and even plain old pieces of text.\n\n\nAll widgets\n go between the line of code to create the \nApp\n and the \napp.display()\n line.\n\n\nfrom guizero import App, Text\napp = App(title=\"Hello world\")\nmessage = Text(app, text=\"Welcome to the Hello world app!\")\napp.display()\n\n\n\n\n\n\nLet\u2019s look at the \nText\n widget code in a bit more detail:\n\n\nmessage = Text(app, text=\"Welcome to the Hello world app!\")\n\n\n\n\n\n\nmessage =\n - The \nText\n object has a name, just like any variable\n\n\nText\n - an \nobject\n which creates a piece of text on the screen\n\n\napp\n \u2013 This tells the \nText\n where it will live. Most of the time your widgets will live directly inside the app.\n\n\ntext=\"Welcome to the Hello world app!\"\n - The text to display\n\n\n\n\nAnd that's it! Now have a look on the documentation pages for the individual widgets to find out more about how to use them.",
            "title": "Getting Started"
        },
        {
            "location": "/start/#getting-started",
            "text": "At the start of every guizero program, choose the widgets you need from the guizero library and import them:  from guizero import App, PushButton, Slider  You only need to import each widget once, and then you can use it in your program as many times as you like.",
            "title": "Getting Started"
        },
        {
            "location": "/start/#hello-world",
            "text": "All guizero projects begin with a main window which is called an  App . At the end of every guizero program you must tell the program to display the app you have just created.  Let's create an app window with the title \"Hello world\":  from guizero import App\napp = App(title=\"Hello world\")\napp.display()  Save and run the code - you've created your first guizero app!",
            "title": "Hello World"
        },
        {
            "location": "/start/#adding-widgets",
            "text": "Widgets are the things which appear on the GUI, such as text boxes, buttons, sliders and even plain old pieces of text.  All widgets  go between the line of code to create the  App  and the  app.display()  line.  from guizero import App, Text\napp = App(title=\"Hello world\")\nmessage = Text(app, text=\"Welcome to the Hello world app!\")\napp.display()   Let\u2019s look at the  Text  widget code in a bit more detail:  message = Text(app, text=\"Welcome to the Hello world app!\")   message =  - The  Text  object has a name, just like any variable  Text  - an  object  which creates a piece of text on the screen  app  \u2013 This tells the  Text  where it will live. Most of the time your widgets will live directly inside the app.  text=\"Welcome to the Hello world app!\"  - The text to display   And that's it! Now have a look on the documentation pages for the individual widgets to find out more about how to use them.",
            "title": "Adding widgets"
        },
        {
            "location": "/layout/",
            "text": "Layouts\n\n\nThe \nApp\n parameter \nlayout\n allows you to specify whether the widgets in your app are placed automatically (\nauto\n), or whether you wish to position them yourself on a grid (\ngrid\n). The default layout is \nauto\n.\n\n\nIf you choose the \ngrid\n layout, this means that when you create a widget (other than the \nApp\n itself) you will need to pass the widget an extra parameter called \ngrid\n which is a list containing \n[x,y]\n coordinates for where you want the widget to appear, like this:\n\n\ntext = Text(app, text=\"Hello world\", grid=[0,1])\n\n\n\n\nThere is no need to specify the width or height of the grid you want - it will expand depending on the coordinates you provide with each widget. However, grid cells containing no objects will have no height or width.\n\n\nUsing grid layout\n\n\nYou can lay components out in a grid and specify where they appear with grid layout.\n\n\n\n\nfrom guizero import App, PushButton\ndef do_nothing():\n    print(\"Nothing happened\")\n\napp = App(title=\"Keypad example\", width=100, height=90, layout=\"grid\")\nbutton1 = PushButton(app, command=do_nothing, text=\"1\", grid=[0,0])\nbutton2 = PushButton(app, command=do_nothing, text=\"2\", grid=[0,1])\nbutton3  = PushButton(app, command=do_nothing, text=\"3\", grid=[0,2])\nbutton4  = PushButton(app, command=do_nothing, text=\"4\", grid=[1,0])\nbutton5  = PushButton(app, command=do_nothing, text=\"5\", grid=[1,1])\nbutton6  = PushButton(app, command=do_nothing, text=\"6\", grid=[1,2])\napp.display()",
            "title": "Layouts"
        },
        {
            "location": "/layout/#layouts",
            "text": "The  App  parameter  layout  allows you to specify whether the widgets in your app are placed automatically ( auto ), or whether you wish to position them yourself on a grid ( grid ). The default layout is  auto .  If you choose the  grid  layout, this means that when you create a widget (other than the  App  itself) you will need to pass the widget an extra parameter called  grid  which is a list containing  [x,y]  coordinates for where you want the widget to appear, like this:  text = Text(app, text=\"Hello world\", grid=[0,1])  There is no need to specify the width or height of the grid you want - it will expand depending on the coordinates you provide with each widget. However, grid cells containing no objects will have no height or width.  Using grid layout  You can lay components out in a grid and specify where they appear with grid layout.   from guizero import App, PushButton\ndef do_nothing():\n    print(\"Nothing happened\")\n\napp = App(title=\"Keypad example\", width=100, height=90, layout=\"grid\")\nbutton1 = PushButton(app, command=do_nothing, text=\"1\", grid=[0,0])\nbutton2 = PushButton(app, command=do_nothing, text=\"2\", grid=[0,1])\nbutton3  = PushButton(app, command=do_nothing, text=\"3\", grid=[0,2])\nbutton4  = PushButton(app, command=do_nothing, text=\"4\", grid=[1,0])\nbutton5  = PushButton(app, command=do_nothing, text=\"5\", grid=[1,1])\nbutton6  = PushButton(app, command=do_nothing, text=\"6\", grid=[1,2])\napp.display()",
            "title": "Layouts"
        },
        {
            "location": "/alerts/",
            "text": "Alerts\n\n\nUsing alerts\n\n\nTo use the alerts you will need to import each one individually at the start of your program. For example:\n\n\nfrom guizero import warn, info\n\n\n\n\nPurpose\n\n\nThese functions pop up a box on the screen that displays a message. The functions available are:\n\n\n\n\nwarn(title, text)\n - popup box with a warning icon\n\n\ninfo(title, text)\n - popup box with an information icon\n\n\nerror(title, text)\n - popup box with an error icon\n\n\nyesno(title, text)\n - popup box with yes and no options. Pressing \nYes\n returns \nTrue\n and pressing \nNo\n returns \nFalse\n.\n\n\n\n\nAll pop up boxes use the native display, so they will look different depending on your operating system.\n\n\nExamples\n\n\nWarning box\n\n\nThis will pop up a warning box with the title \n\"Uh oh!\"\n and the message \n\"You are almost out of biscuits!\"\n.\n\n\nfrom guizero import App, warn\napp = App(title=\"Biscuit monitor\")\nwarn(\"Uh oh!\", \"You are almost out of biscuits!\")\napp.display()\n\n\n\n\nOn Windows, the box looks like this:\n\n\n\n\nThe \ninfo\n and \nerror\n boxes work in exactly the same way but will display different icons.\n\n\nYes/No box\n\n\nWhen this function is called it returns a \nboolean\n value.\n\n\n\n\nIf \nYes\n was pressed, return \nTrue\n\n\nIf \nNo\n was pressed, return \nFalse\n\n\n\n\nYou can store this value in a variable and test it:\n\n\nfrom guizero import App, yesno, info, error\napp = App(title=\"Snowman\")\nbuild_a_snowman = yesno(\"A question...\", \"Do you want to build a snowman?\")\nif build_a_snowman == True:\n    info(\"Snowman\", \"It doesn't have to be a snowman\")\nelse:\n    error(\"Snowman\", \"Okay bye...\")\napp.display()\n\n\n\n\nThis code will first display the yes/no box\n\n\n\n\nIf \nYes\n is pressed, an information box will be displayed:\n\n\n\n\nIf \nNo\n is pressed, an error box will be displayed\n\n\n\n\nExample: Using an alert as a callback\n\n\nYou can also use these functions in a \ncallback\n (when you have to provide a function for another widget to call). Here is an example with a \nPushButton\n which pops up an \ninfo\n box when it is pressed.\n\n\nfrom guizero import App, PushButton, info\napp = App()\nbutton = PushButton(app, command=info, args=[\"Info\", \"You pressed the button\"])\napp.display()\n\n\n\n\nThe arguments provided to the \nPushButton\n are:\n\n\n\n\nWhere the button should be created (within the \napp\n)\n\n\nThe name of the function to call when pressed (\ninfo\n)\n\n\nA list of the arguments to the function you are calling (values for the \ntitle\n and \nmessage\n arguments for the \ninfo\n function)\n\n\n\n\nExample: Do you really want to close?\n\n\nYou can use a \nyesno\n box to check whether someone really wants to exit your app. If they click yes, the app is closed, if not, nothing happens and they can continue with what they were doing.\n\n\nfrom guizero import App, Text, yesno\n\n# Ask the user if they really want to close the window\ndef do_this_on_close():\n    if yesno(\"Close\", \"Do you want to quit?\"):\n        app.destroy()\n\napp = App()\n\ntitle = Text(app, text=\"blank app\")\n\n# When the user tries to close the window, run the function do_this_on_close()\napp.on_close(do_this_on_close)\n\napp.display()",
            "title": "Alerts"
        },
        {
            "location": "/alerts/#alerts",
            "text": "",
            "title": "Alerts"
        },
        {
            "location": "/alerts/#using-alerts",
            "text": "To use the alerts you will need to import each one individually at the start of your program. For example:  from guizero import warn, info",
            "title": "Using alerts"
        },
        {
            "location": "/alerts/#purpose",
            "text": "These functions pop up a box on the screen that displays a message. The functions available are:   warn(title, text)  - popup box with a warning icon  info(title, text)  - popup box with an information icon  error(title, text)  - popup box with an error icon  yesno(title, text)  - popup box with yes and no options. Pressing  Yes  returns  True  and pressing  No  returns  False .   All pop up boxes use the native display, so they will look different depending on your operating system.",
            "title": "Purpose"
        },
        {
            "location": "/alerts/#examples",
            "text": "Warning box  This will pop up a warning box with the title  \"Uh oh!\"  and the message  \"You are almost out of biscuits!\" .  from guizero import App, warn\napp = App(title=\"Biscuit monitor\")\nwarn(\"Uh oh!\", \"You are almost out of biscuits!\")\napp.display()  On Windows, the box looks like this:   The  info  and  error  boxes work in exactly the same way but will display different icons.  Yes/No box  When this function is called it returns a  boolean  value.   If  Yes  was pressed, return  True  If  No  was pressed, return  False   You can store this value in a variable and test it:  from guizero import App, yesno, info, error\napp = App(title=\"Snowman\")\nbuild_a_snowman = yesno(\"A question...\", \"Do you want to build a snowman?\")\nif build_a_snowman == True:\n    info(\"Snowman\", \"It doesn't have to be a snowman\")\nelse:\n    error(\"Snowman\", \"Okay bye...\")\napp.display()  This code will first display the yes/no box   If  Yes  is pressed, an information box will be displayed:   If  No  is pressed, an error box will be displayed   Example: Using an alert as a callback  You can also use these functions in a  callback  (when you have to provide a function for another widget to call). Here is an example with a  PushButton  which pops up an  info  box when it is pressed.  from guizero import App, PushButton, info\napp = App()\nbutton = PushButton(app, command=info, args=[\"Info\", \"You pressed the button\"])\napp.display()  The arguments provided to the  PushButton  are:   Where the button should be created (within the  app )  The name of the function to call when pressed ( info )  A list of the arguments to the function you are calling (values for the  title  and  message  arguments for the  info  function)   Example: Do you really want to close?  You can use a  yesno  box to check whether someone really wants to exit your app. If they click yes, the app is closed, if not, nothing happens and they can continue with what they were doing.  from guizero import App, Text, yesno\n\n# Ask the user if they really want to close the window\ndef do_this_on_close():\n    if yesno(\"Close\", \"Do you want to quit?\"):\n        app.destroy()\n\napp = App()\n\ntitle = Text(app, text=\"blank app\")\n\n# When the user tries to close the window, run the function do_this_on_close()\napp.on_close(do_this_on_close)\n\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/usingtk/",
            "text": "Using tkinter methods\n\n\nIf you are an advanced user, you can still make use of any tkinter method which is not implemented in guizero.\n\n\nEach guizero widget itself contains a tk widget - you can find out which by looking on the guizero documentation page for the widget. For example, a guizero \nTextBox\n contains a tkinter \nEntry\n object. You can always access the internal object using the syntax \n<object_name>.tk\n.\n\n\nUsing a tkinter method on a guizero object\n\n\nIn this example, we have guizero \nApp\n and \nTextBox\n widgets.\n\n\nfrom guizero import App, TextBox\napp = App()\nname = TextBox(app)\napp.display()\n\n\n\n\nYou want to make the text in the box appear red, but you discover that at the moment this isn't possible in guizero. So instead, you access the internal tk widget directly using \n<object_name>.tk\n and then you call the tkinter method:\n\n\nfrom guizero import App, TextBox\napp = App()\nname = TextBox(app, text=\"Laura\")\nname.tk.config(foreground=\"red\")    # config() is a tkinter method\napp.display()\n\n\n\n\nYou can combine the use of \nguizero\n and \ntkinter\n seamlessly in a program, taking advantage of the simplified syntax of guizero whilst still being able to access the full range of functionality in tkinter if you need it.",
            "title": "Using tkinter methods"
        },
        {
            "location": "/usingtk/#using-tkinter-methods",
            "text": "If you are an advanced user, you can still make use of any tkinter method which is not implemented in guizero.  Each guizero widget itself contains a tk widget - you can find out which by looking on the guizero documentation page for the widget. For example, a guizero  TextBox  contains a tkinter  Entry  object. You can always access the internal object using the syntax  <object_name>.tk .",
            "title": "Using tkinter methods"
        },
        {
            "location": "/usingtk/#using-a-tkinter-method-on-a-guizero-object",
            "text": "In this example, we have guizero  App  and  TextBox  widgets.  from guizero import App, TextBox\napp = App()\nname = TextBox(app)\napp.display()  You want to make the text in the box appear red, but you discover that at the moment this isn't possible in guizero. So instead, you access the internal tk widget directly using  <object_name>.tk  and then you call the tkinter method:  from guizero import App, TextBox\napp = App()\nname = TextBox(app, text=\"Laura\")\nname.tk.config(foreground=\"red\")    # config() is a tkinter method\napp.display()  You can combine the use of  guizero  and  tkinter  seamlessly in a program, taking advantage of the simplified syntax of guizero whilst still being able to access the full range of functionality in tkinter if you need it.",
            "title": "Using a tkinter method on a guizero object"
        },
        {
            "location": "/blocking/",
            "text": "Loops and sleeping\n\n\nYou may be used to writing programs which contain loops or make use of the \nsleep()\n command, but find when you try to use these with guizero they cause your GUI to freeze. This is because guizero (in common with almost all GUIs) operates an \nevent driven\n model of programming which may be different to the one you are familiar with.\n\n\nYour first guizero program might look a bit like this:\n\n\nfrom guizero import App\napp = App(\"Hello world\")\napp.display()\n\n\n\n\nThe line of code \napp.display()\n doesn't just display the app - it enters an \ninfinite event loop\n which is watching and waiting for events to happen on the GUI. Events include things like the user clicking on a button, moving a slider, typing in a text box etc. No code written after this line will ever execute because the event loop is infinite.\n\n\nExample\n\n\nSuppose you want a counter on your GUI to start counting up by 1 every second. You might be tempted to write a program like this:\n\n\nfrom guizero import App, Text\nfrom time import sleep\n\napp = App(\"Hello world\")\ntext = Text(app, text=\"1\")\nwhile True:\n    text.value = int(text.value) + 1\n    sleep(1)\napp.display()\n\n\n\n\nIf you run this program, you'll see that this does not have the desired effect - your program crashes! This is because you have blocked the updating of your GUI in two ways:\n\n\n\n\n\n\nThe \nsleep()\n command - whilst your program is sleeping, the GUI will not update and you will not be able to click on anything.\n\n\n\n\n\n\nThe \nwhile\n loop - once you enter this loop, your GUI will never update ever again and will probably crash.\n\n\n\n\n\n\nSolution\n\n\nThis behaviour is not a bug within guizero or tkinter.\n\n\nYou must write GUI based programs in a different way to the one you may be used to. If you want to repeatedly perform an action you would do it like this:\n\n\n\n\n\n\nWrite a function which performs the desired action (in this example \ncounter()\n)\n\n\n\n\n\n\nSet a \ncallback\n to that function. You can either schedule the same callback to occur repeatedly after a given number of milliseconds (in this example \n1000\n), or you can schedule it only once.\n\n\n\n\n\n\nfrom guizero import App, Text\n\n# Action you would like to perform\ndef counter():\n    text.value = int(text.value) + 1\n\napp = App(\"Hello world\")\ntext = Text(app, text=\"1\")\ntext.repeat(1000, counter)  # Schedule call to counter() every 1000ms\napp.display()",
            "title": "Loops and sleeping"
        },
        {
            "location": "/blocking/#loops-and-sleeping",
            "text": "You may be used to writing programs which contain loops or make use of the  sleep()  command, but find when you try to use these with guizero they cause your GUI to freeze. This is because guizero (in common with almost all GUIs) operates an  event driven  model of programming which may be different to the one you are familiar with.  Your first guizero program might look a bit like this:  from guizero import App\napp = App(\"Hello world\")\napp.display()  The line of code  app.display()  doesn't just display the app - it enters an  infinite event loop  which is watching and waiting for events to happen on the GUI. Events include things like the user clicking on a button, moving a slider, typing in a text box etc. No code written after this line will ever execute because the event loop is infinite.",
            "title": "Loops and sleeping"
        },
        {
            "location": "/blocking/#example",
            "text": "Suppose you want a counter on your GUI to start counting up by 1 every second. You might be tempted to write a program like this:  from guizero import App, Text\nfrom time import sleep\n\napp = App(\"Hello world\")\ntext = Text(app, text=\"1\")\nwhile True:\n    text.value = int(text.value) + 1\n    sleep(1)\napp.display()  If you run this program, you'll see that this does not have the desired effect - your program crashes! This is because you have blocked the updating of your GUI in two ways:    The  sleep()  command - whilst your program is sleeping, the GUI will not update and you will not be able to click on anything.    The  while  loop - once you enter this loop, your GUI will never update ever again and will probably crash.",
            "title": "Example"
        },
        {
            "location": "/blocking/#solution",
            "text": "This behaviour is not a bug within guizero or tkinter.  You must write GUI based programs in a different way to the one you may be used to. If you want to repeatedly perform an action you would do it like this:    Write a function which performs the desired action (in this example  counter() )    Set a  callback  to that function. You can either schedule the same callback to occur repeatedly after a given number of milliseconds (in this example  1000 ), or you can schedule it only once.    from guizero import App, Text\n\n# Action you would like to perform\ndef counter():\n    text.value = int(text.value) + 1\n\napp = App(\"Hello world\")\ntext = Text(app, text=\"1\")\ntext.repeat(1000, counter)  # Schedule call to counter() every 1000ms\napp.display()",
            "title": "Solution"
        },
        {
            "location": "/resources/",
            "text": "Examples and resources\n\n\n\n\n\n\nGetting started with GUIs\n - a beginners guide to guizero by the Raspberry Pi Foundation\n\n\n\n\n\n\nCat name generator\n - materials for a kids workshop, first run at the \nCotswold Jam\n\n\n\n\n\n\nName your pet\n - article on page 42 of \nHello World\n magazine issue 2.\n\n\n\n\n\n\nExample programs\n - some simple example programs\n\n\n\n\n\n\nIf you have created an educational resource using guizero, please share it with us by submitting a pull request to the \nexamples folder\n on GitHub",
            "title": "Examples and resources"
        },
        {
            "location": "/resources/#examples-and-resources",
            "text": "Getting started with GUIs  - a beginners guide to guizero by the Raspberry Pi Foundation    Cat name generator  - materials for a kids workshop, first run at the  Cotswold Jam    Name your pet  - article on page 42 of  Hello World  magazine issue 2.    Example programs  - some simple example programs    If you have created an educational resource using guizero, please share it with us by submitting a pull request to the  examples folder  on GitHub",
            "title": "Examples and resources"
        },
        {
            "location": "/app/",
            "text": "App\n\n\n(Contains a \ntkinter.Tk\n object)\n\n\n__init__(self, title=\"guizero\", width=500, height=500, layout=\"auto\", bgcolor=None, bg=None)\n\n\nWhat is it?\n\n\nThe \nApp\n object is the basis of all GUIs created using guizero. It is the main window which contains all of the other widgets.\n\n\n\n\nHow do I make one?\n\n\nCreate an \nApp\n object like this:\n\n\nfrom guizero import App\napp = App()\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create an \nApp\n object you can specify any of the following parameters, all of which are optional. Specify parameters in the brackets like this: \napp = App(bg=\"red\", height=200)\n\n\n\n\n\n\n\n\nParameter\n\n\nData type\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbg\n\n\nstring\n\n\nNone\n\n\nNo\n\n\nThe background colour of the app window. Takes a RGB h ex colour (e.g. #0099ff) or a known colour string (e.g. \"black\").\n\n\n\n\n\n\nheight\n\n\nint\n\n\n500\n\n\nNo\n\n\nThe height of the window in pixels.\n\n\n\n\n\n\nlayout\n\n\nstring\n\n\n\"auto\"\n\n\nNo\n\n\nWhether widgets pack themselves (\n\"auto\"\n) or you specify their position on a grid (\n\"grid\"\n)\n\n\n\n\n\n\ntitle\n\n\nstring\n\n\n\"guizero\"\n\n\nNo\n\n\nThe title displayed in the bar at the top of the window.\n\n\n\n\n\n\nwidth\n\n\nint\n\n\n500\n\n\nNo\n\n\nThe width of the window in pixels.\n\n\n\n\n\n\nbgcolor\n\n\nstring\n\n\nNone\n\n\nNo\n\n\nReplaced by \nbg\n parameter\n\n\n\n\n\n\n\n\nParameters in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nMethods\n\n\nYou can call the following methods on an \nApp\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisplay()\n\n\n-\n\n\n-\n\n\nDisplays the app on the screen. You \nMUST\n call this method at the end of your program to display the app on the screen.\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\non_close(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCalls the given function when the user tries to close the window.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nset_title(title)\n\n\ntitle (string)\n\n\n-\n\n\nReplaced by \ntitle\n property\n\n\n\n\n\n\nbgcolor\n\n\nbgcolor (string)\n\n\n-\n\n\nReplaced by \nbg\n property\n\n\n\n\n\n\n\n\nParameters in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbg\n\n\nstring\n\n\nThe background colour of the window\n\n\n\n\n\n\nheight\n\n\nint\n\n\nThe height of the window\n\n\n\n\n\n\ntitle\n\n\nstring\n\n\nThe title of the window\n\n\n\n\n\n\nwidth\n\n\nint\n\n\nThe width of the window\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nApp\n object is called \napp\n you would write \napp.title\n.\n\n\nYou can \nset\n the property (for example \napp.title = \"Hello world\"\n) or \nget\n the value of the property to use (for example \nprint(app.title)\n).\n\n\nExamples\n\n\nCreating an App object\n\n\nCreate an \nApp\n object by calling the \nApp()\n constructor. You should give the object a name so you can refer to it later - in this case we have called it \napp\n. It is best to keep the name you give to your \nApp\n object quite short, as you will have to use it to tell other widgets where they should be stored.\n\n\nAt the end of the program you \nMUST\n tell the app object to begin the display loop.\n\n\nfrom guizero import App\napp = App(title=\"My app\", height=300, width=200)\napp.display()\n\n\n\n\nChanging the title\n\n\nYou can change the title of the app object once it has been created like this:\n\n\nfrom guizero import App\napp = App(title=\"My app\", height=300, width=200)\napp.title = \"A different title\"\napp.display()\n\n\n\n\nThis will display the app with the updated title:",
            "title": "App"
        },
        {
            "location": "/app/#app",
            "text": "(Contains a  tkinter.Tk  object)  __init__(self, title=\"guizero\", width=500, height=500, layout=\"auto\", bgcolor=None, bg=None)",
            "title": "App"
        },
        {
            "location": "/app/#what-is-it",
            "text": "The  App  object is the basis of all GUIs created using guizero. It is the main window which contains all of the other widgets.",
            "title": "What is it?"
        },
        {
            "location": "/app/#how-do-i-make-one",
            "text": "Create an  App  object like this:  from guizero import App\napp = App()\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/app/#starting-parameters",
            "text": "When you create an  App  object you can specify any of the following parameters, all of which are optional. Specify parameters in the brackets like this:  app = App(bg=\"red\", height=200)     Parameter  Data type  Default  Compulsory  Description      bg  string  None  No  The background colour of the app window. Takes a RGB h ex colour (e.g. #0099ff) or a known colour string (e.g. \"black\").    height  int  500  No  The height of the window in pixels.    layout  string  \"auto\"  No  Whether widgets pack themselves ( \"auto\" ) or you specify their position on a grid ( \"grid\" )    title  string  \"guizero\"  No  The title displayed in the bar at the top of the window.    width  int  500  No  The width of the window in pixels.    bgcolor  string  None  No  Replaced by  bg  parameter     Parameters in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Starting parameters"
        },
        {
            "location": "/app/#methods",
            "text": "You can call the following methods on an  App  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    display()  -  -  Displays the app on the screen. You  MUST  call this method at the end of your program to display the app on the screen.    focus()  -  -  Gives focus to the widget    on_close(command)  command (function name)  -  Calls the given function when the user tries to close the window.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    set_title(title)  title (string)  -  Replaced by  title  property    bgcolor  bgcolor (string)  -  Replaced by  bg  property     Parameters in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/app/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      bg  string  The background colour of the window    height  int  The height of the window    title  string  The title of the window    width  int  The width of the window     Refer to a property as  <name of widget>.property . For example, if your  App  object is called  app  you would write  app.title .  You can  set  the property (for example  app.title = \"Hello world\" ) or  get  the value of the property to use (for example  print(app.title) ).",
            "title": "Properties"
        },
        {
            "location": "/app/#examples",
            "text": "Creating an App object  Create an  App  object by calling the  App()  constructor. You should give the object a name so you can refer to it later - in this case we have called it  app . It is best to keep the name you give to your  App  object quite short, as you will have to use it to tell other widgets where they should be stored.  At the end of the program you  MUST  tell the app object to begin the display loop.  from guizero import App\napp = App(title=\"My app\", height=300, width=200)\napp.display()  Changing the title  You can change the title of the app object once it has been created like this:  from guizero import App\napp = App(title=\"My app\", height=300, width=200)\napp.title = \"A different title\"\napp.display()  This will display the app with the updated title:",
            "title": "Examples"
        },
        {
            "location": "/box/",
            "text": "Box\n\n\n(Contains a \ntkinter.Frame\n object)\n\n\n__init__(self, master, layout=\"auto\", grid=None, align=None)\n\n\nWhat is it?\n\n\nThe \nBox\n object is an invisible container which can contain other widgets. It is the only object other than \nApp\n which can act as the \nmaster\n for other objects and can have its own layout manager.\n\n\nYou can use the \nBox\n object to group other objects within your GUI.\n\n\nHow do I make one?\n\n\nCreate a \nBox\n object like this:\n\n\nfrom guizero import App, Box\napp = App()\nbox = Box(app)\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nBox\n object you \nmust\n specify a master, and you can specify any of the optional parameters. Specify parameters in the brackets like this: \nbox = Box(app, layout=\"grid\")\n\n\n\n\n\n\n\n\nParameter\n\n\nData type\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp\n\n\n-\n\n\nYes\n\n\nThe \nApp\n object to which this box belongs\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ngrid\n\n\nList\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nlayout\n\n\nstring\n\n\n\"auto\"\n\n\n-\n\n\nWhether widgets \ninside this box\n pack themselves (\n\"auto\"\n) or you specify their position on a grid (\n\"grid\"\n)\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nBox\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\n\n\nProperties\n\n\nThere are no properties for the \nBox\n object.\n\n\nExamples\n\n\nPutting widgets in a Box\n\n\nA \nBox\n object is invisible, but it can contain other widgets. In this example, there are two \nText\n objects. One has \nbox\n as its master, the other has \napp\n as its master.\n\n\nfrom guizero import App, Box, Text\napp = App(title=\"My app\", height=300, width=400)\nbox = Box(app)\ntext1 = Text(box, text=\"Hello from the box\", size=14, text_color=\"red\", font=\"Arial\")\ntext2 = Text(app, text=\"Hello from the app\", size=14, text_color=\"blue\", font=\"Courier New\")\napp.display()\n\n\n\n\n\n\nGrouping objects within a Box\n\n\nIt is useful to put objects in a box to group them together. For example here we have given the \napp\n a grid layout, then placed some text at [0,0] and the \nBox\n object at [1,0]. This means that the text will appear on the left, and the contents of the Box will appear on the right.\n\n\nThe \nBox\n object itself has a grid layout and contains six buttons which are positioned on a \nseparate\n grid layout belonging to the box.\n\n\nfrom guizero import App, Text, Box, PushButton\ndef do_nothing():\n    return 0\n\napp = App(title=\"My app\", height=300, width=300, layout=\"grid\")\ntext = Text(app, text=\"Some text here\", grid=[0,0])\nbox = Box(app, layout=\"grid\", grid=[1,0])\nbutton1 = PushButton(box, command=do_nothing, text=\"1\", grid=[0,0])\nbutton2 = PushButton(box, command=do_nothing, text=\"2\", grid=[1,0])\nbutton3 = PushButton(box, command=do_nothing, text=\"3\", grid=[2,0])\nbutton4 = PushButton(box, command=do_nothing, text=\"4\", grid=[0,1])\nbutton5 = PushButton(box, command=do_nothing, text=\"5\", grid=[1,1])\nbutton6 = PushButton(box, command=do_nothing, text=\"6\", grid=[2,1])\napp.display()",
            "title": "Box"
        },
        {
            "location": "/box/#box",
            "text": "(Contains a  tkinter.Frame  object)  __init__(self, master, layout=\"auto\", grid=None, align=None)",
            "title": "Box"
        },
        {
            "location": "/box/#what-is-it",
            "text": "The  Box  object is an invisible container which can contain other widgets. It is the only object other than  App  which can act as the  master  for other objects and can have its own layout manager.  You can use the  Box  object to group other objects within your GUI.",
            "title": "What is it?"
        },
        {
            "location": "/box/#how-do-i-make-one",
            "text": "Create a  Box  object like this:  from guizero import App, Box\napp = App()\nbox = Box(app)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/box/#starting-parameters",
            "text": "When you create a  Box  object you  must  specify a master, and you can specify any of the optional parameters. Specify parameters in the brackets like this:  box = Box(app, layout=\"grid\")     Parameter  Data type  Default  Compulsory  Description      master  App  -  Yes  The  App  object to which this box belongs    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    grid  List  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    layout  string  \"auto\"  -  Whether widgets  inside this box  pack themselves ( \"auto\" ) or you specify their position on a grid ( \"grid\" )",
            "title": "Starting parameters"
        },
        {
            "location": "/box/#methods",
            "text": "You can call the following methods on a  Box  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the widget if it was previously hidden",
            "title": "Methods"
        },
        {
            "location": "/box/#properties",
            "text": "There are no properties for the  Box  object.",
            "title": "Properties"
        },
        {
            "location": "/box/#examples",
            "text": "Putting widgets in a Box  A  Box  object is invisible, but it can contain other widgets. In this example, there are two  Text  objects. One has  box  as its master, the other has  app  as its master.  from guizero import App, Box, Text\napp = App(title=\"My app\", height=300, width=400)\nbox = Box(app)\ntext1 = Text(box, text=\"Hello from the box\", size=14, text_color=\"red\", font=\"Arial\")\ntext2 = Text(app, text=\"Hello from the app\", size=14, text_color=\"blue\", font=\"Courier New\")\napp.display()   Grouping objects within a Box  It is useful to put objects in a box to group them together. For example here we have given the  app  a grid layout, then placed some text at [0,0] and the  Box  object at [1,0]. This means that the text will appear on the left, and the contents of the Box will appear on the right.  The  Box  object itself has a grid layout and contains six buttons which are positioned on a  separate  grid layout belonging to the box.  from guizero import App, Text, Box, PushButton\ndef do_nothing():\n    return 0\n\napp = App(title=\"My app\", height=300, width=300, layout=\"grid\")\ntext = Text(app, text=\"Some text here\", grid=[0,0])\nbox = Box(app, layout=\"grid\", grid=[1,0])\nbutton1 = PushButton(box, command=do_nothing, text=\"1\", grid=[0,0])\nbutton2 = PushButton(box, command=do_nothing, text=\"2\", grid=[1,0])\nbutton3 = PushButton(box, command=do_nothing, text=\"3\", grid=[2,0])\nbutton4 = PushButton(box, command=do_nothing, text=\"4\", grid=[0,1])\nbutton5 = PushButton(box, command=do_nothing, text=\"5\", grid=[1,1])\nbutton6 = PushButton(box, command=do_nothing, text=\"6\", grid=[2,1])\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/buttongroup/",
            "text": "ButtonGroup\n\n\n(Contains a \ntkinter.Frame\n object)\n\n\n__init__(self, master, options, selected, horizontal=False, command=None, grid=None, align=None)\n\n\nWhat is it?\n\n\nThe \nButtonGroup\n object displays a group of radio buttons, allowing the user to choose a single option.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nButtonGroup\n object like this:\n\n\nfrom guizero import App, ButtonGroup\napp = App()\nchoice = ButtonGroup(app, options=[\"cheese\", \"ham\", \"salad\"], selected=1)\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nButtonGroup\n object you \nmust\n specify \nmaster\n, \noptions\n and \nselected\n and you can specify any of the optional parameters. Specify parameters in the brackets like this: \nchoice = ButtonGroup(app, options=[\"cheese\", \"ham\", \"salad\"], selected=1)\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\noptions\n\n\nlist or 2D List\n\n\n-\n\n\nYes\n\n\nEither a list or a 2D list of [text, value] pairs. If a 2D list is specified, the first item in the pair will be displayed on the interface, and the second item will be a hidden value associated with this option. If a list is specified, the options will be automatically numbered with hidden values, beginning at 1.\n\n\n\n\n\n\nselected\n\n\nstring\n\n\n-\n\n\nYes\n\n\nThe option that should be selected. If the options are specified as a list, the selected option should be the number of the desired option, beginning at 1. If a 2D list is specified, this should be the \nhidden value\n associated with one of the options.\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when the selected option changes.\n\n\n\n\n\n\ngrid\n\n\nlist [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nhorizontal\n\n\nboolean\n\n\nFalse\n\n\n-\n\n\nWhether the buttons stack vertically or horizontally. (Defaults to vertical)\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on an \nButtonGroup\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nget_group_as_list()\n\n\n-\n\n\nlist\n\n\nReturns a list containing all of the text/hidden value pairs from the ButtonGroup (useful for debugging)\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\nget()\n\n\n-\n\n\nstring\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\nset(value)\n\n\nvalue (string)\n\n\n-\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\n\n\nParameters in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe hidden value associated with the currently selected option\n\n\n\n\n\n\nvalue_text\n\n\nstring\n\n\nThe text associated with the currently selected option\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nButtonGroup\n object is called \nchoice\n you would write \nchoice.value\n.\n\n\nYou can \nset\n the property (for example \nchoice.value = \"2\"\n) or \nget\n the value of the property to use (for example \nprint(choice.value)\n).\n\n\nExamples\n\n\nCreating a ButtonGroup with a 2D list\n\n\nIf you want to create a ButtonGroup object with your own hidden values you can specify a 2D list of options:\n\n\nfrom guizero import App, ButtonGroup, Text\n\ndef update_text():\n    what_is_selected.value = activities.value\n\napp = App()\nactivities = ButtonGroup(app, options=[\n                              [\"Roller Skating\", \"skate\"],\n                              [\"White water rafting\", \"WWR\"],\n                              [\"Mountain climbing\", \"climb\"]\n                            ],\n                            selected=\"skate\", command=update_text)\n\nwhat_is_selected = Text(app, text=\"skate\")\napp.display()",
            "title": "ButtonGroup"
        },
        {
            "location": "/buttongroup/#buttongroup",
            "text": "(Contains a  tkinter.Frame  object)  __init__(self, master, options, selected, horizontal=False, command=None, grid=None, align=None)",
            "title": "ButtonGroup"
        },
        {
            "location": "/buttongroup/#what-is-it",
            "text": "The  ButtonGroup  object displays a group of radio buttons, allowing the user to choose a single option.",
            "title": "What is it?"
        },
        {
            "location": "/buttongroup/#how-do-i-make-one",
            "text": "Create a  ButtonGroup  object like this:  from guizero import App, ButtonGroup\napp = App()\nchoice = ButtonGroup(app, options=[\"cheese\", \"ham\", \"salad\"], selected=1)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/buttongroup/#starting-parameters",
            "text": "When you create a  ButtonGroup  object you  must  specify  master ,  options  and  selected  and you can specify any of the optional parameters. Specify parameters in the brackets like this:  choice = ButtonGroup(app, options=[\"cheese\", \"ham\", \"salad\"], selected=1)     Parameter  Takes  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    options  list or 2D List  -  Yes  Either a list or a 2D list of [text, value] pairs. If a 2D list is specified, the first item in the pair will be displayed on the interface, and the second item will be a hidden value associated with this option. If a list is specified, the options will be automatically numbered with hidden values, beginning at 1.    selected  string  -  Yes  The option that should be selected. If the options are specified as a list, the selected option should be the number of the desired option, beginning at 1. If a 2D list is specified, this should be the  hidden value  associated with one of the options.    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    command  function name  None  -  The name of a function to call when the selected option changes.    grid  list [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    horizontal  boolean  False  -  Whether the buttons stack vertically or horizontally. (Defaults to vertical)",
            "title": "Starting parameters"
        },
        {
            "location": "/buttongroup/#methods",
            "text": "You can call the following methods on an  ButtonGroup  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    focus()  -  -  Gives focus to the widget    get_group_as_list()  -  list  Returns a list containing all of the text/hidden value pairs from the ButtonGroup (useful for debugging)    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the widget if it was previously hidden    get()  -  string  Replaced by  value  property    set(value)  value (string)  -  Replaced by  value  property     Parameters in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/buttongroup/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      value  string  The hidden value associated with the currently selected option    value_text  string  The text associated with the currently selected option     Refer to a property as  <name of widget>.property . For example, if your  ButtonGroup  object is called  choice  you would write  choice.value .  You can  set  the property (for example  choice.value = \"2\" ) or  get  the value of the property to use (for example  print(choice.value) ).",
            "title": "Properties"
        },
        {
            "location": "/buttongroup/#examples",
            "text": "Creating a ButtonGroup with a 2D list  If you want to create a ButtonGroup object with your own hidden values you can specify a 2D list of options:  from guizero import App, ButtonGroup, Text\n\ndef update_text():\n    what_is_selected.value = activities.value\n\napp = App()\nactivities = ButtonGroup(app, options=[\n                              [\"Roller Skating\", \"skate\"],\n                              [\"White water rafting\", \"WWR\"],\n                              [\"Mountain climbing\", \"climb\"]\n                            ],\n                            selected=\"skate\", command=update_text)\n\nwhat_is_selected = Text(app, text=\"skate\")\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/checkbox/",
            "text": "CheckBox\n\n\n(Contains a \ntkinter.Checkbutton\n object)\n\n\n__init__(self, master, text, command=None, grid=None, align=None)\n\n\nWhat is it?\n\n\nThe \nCheckBox\n object displays a check box to allow an option to be ticked or unticked\n\n\n\n\nHow do I make one?\n\n\nCreate a \nCheckBox\n object like this:\n\n\nfrom guizero import App, CheckBox\napp = App()\ncheckbox = CheckBox(app, text=\"Add extra glitter\")\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nCheckBox\n object you \nmust\n specify \nmaster\n and \ntext\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \ncheckbox = CheckBox(app, text=\"Add extra glitter\")\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\ntext\n\n\nstring\n\n\n-\n\n\nYes\n\n\nThe text to display next to the check box\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when this checkbox is ticked/unticked\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nCheckBox\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\ntoggle()\n\n\n-\n\n\n-\n\n\nSwitches the \nCheckBox\n to the opposite of its current value. i.e. if it is ticked, untick it and vice versa\n\n\n\n\n\n\nchange_text(newtext)\n\n\nnewtext (string)\n\n\n-\n\n\nReplaced by the \ntext\n property\n\n\n\n\n\n\nget_text()\n\n\n-\n\n\nstring\n\n\nReplaced by the \ntext\n property\n\n\n\n\n\n\nget_value()\n\n\n-\n\n\nint\n\n\nReplaced by the \nvalue\n property\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\ntext\n\n\nstring\n\n\nThe text associated with the checkbox\n\n\n\n\n\n\nvalue\n\n\nint\n\n\n1\n if the CheckBox is ticked or \n0\n if it is not ticked\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nCheckBox\n object is called \ncheckbox\n you would write \ncheckbox.value\n.\n\n\nYou can \nset\n the property (for example \ncheckbox.value = 1\n) or \nget\n the value of the property to use (for example \nprint(checkbox.value)\n).\n\n\nExamples\n\n\nCreating multiple CheckBoxes\n\n\nCreate multiple CheckBoxes like this.\n\n\nfrom guizero import App, CheckBox\napp = App()\nglitter = CheckBox(app, text=\"Add glitter\")\nsparkles = CheckBox(app, text=\"Add sparkles\")\napp.display()\n\n\n\n\nCalling a function when a CheckBox value changes\n\n\nYou can call a function when the value of a CheckBox changes (becomes checked or unchecked). In this particular example all three CheckBoxes call the same function, but it is possible for each CheckBox object to call a different function.\n\n\nfrom guizero import App, Text, CheckBox, TextBox\ndef calculate_extras():\n    total = 0\n    if syrup.value == 1:\n        total += 20\n    if sprinkles.value == 1:\n        total += 10\n    if cream.value == 1:\n        total += 50\n    cost.value = total\n\n\napp = App()\n\nquestions = Text(app, text=\"What would you like with your coffee?\")\n\nsyrup = CheckBox(app, text=\"Caramel syrup (20p)\", command=calculate_extras)\nsprinkles = CheckBox(app, text=\"Chocolate sprinkles (10p)\", command=calculate_extras)\ncream = CheckBox(app, text=\"Whipped cream (50p)\", command=calculate_extras)\n\ncost_of_extras = Text(app, text=\"Cost of extras:\")\ncost = TextBox(app, text=\"0\")\n\napp.display()",
            "title": "CheckBox"
        },
        {
            "location": "/checkbox/#checkbox",
            "text": "(Contains a  tkinter.Checkbutton  object)  __init__(self, master, text, command=None, grid=None, align=None)",
            "title": "CheckBox"
        },
        {
            "location": "/checkbox/#what-is-it",
            "text": "The  CheckBox  object displays a check box to allow an option to be ticked or unticked",
            "title": "What is it?"
        },
        {
            "location": "/checkbox/#how-do-i-make-one",
            "text": "Create a  CheckBox  object like this:  from guizero import App, CheckBox\napp = App()\ncheckbox = CheckBox(app, text=\"Add extra glitter\")\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/checkbox/#starting-parameters",
            "text": "When you create a  CheckBox  object you  must  specify  master  and  text  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  checkbox = CheckBox(app, text=\"Add extra glitter\")     Parameter  Takes  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    text  string  -  Yes  The text to display next to the check box    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    command  function name  None  -  The name of a function to call when this checkbox is ticked/unticked    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.",
            "title": "Starting parameters"
        },
        {
            "location": "/checkbox/#methods",
            "text": "You can call the following methods on a  CheckBox  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the widget if it was previously hidden    toggle()  -  -  Switches the  CheckBox  to the opposite of its current value. i.e. if it is ticked, untick it and vice versa    change_text(newtext)  newtext (string)  -  Replaced by the  text  property    get_text()  -  string  Replaced by the  text  property    get_value()  -  int  Replaced by the  value  property     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/checkbox/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      enabled  boolean  True  if the widget is enabled    text  string  The text associated with the checkbox    value  int  1  if the CheckBox is ticked or  0  if it is not ticked     Refer to a property as  <name of widget>.property . For example, if your  CheckBox  object is called  checkbox  you would write  checkbox.value .  You can  set  the property (for example  checkbox.value = 1 ) or  get  the value of the property to use (for example  print(checkbox.value) ).",
            "title": "Properties"
        },
        {
            "location": "/checkbox/#examples",
            "text": "Creating multiple CheckBoxes  Create multiple CheckBoxes like this.  from guizero import App, CheckBox\napp = App()\nglitter = CheckBox(app, text=\"Add glitter\")\nsparkles = CheckBox(app, text=\"Add sparkles\")\napp.display()  Calling a function when a CheckBox value changes  You can call a function when the value of a CheckBox changes (becomes checked or unchecked). In this particular example all three CheckBoxes call the same function, but it is possible for each CheckBox object to call a different function.  from guizero import App, Text, CheckBox, TextBox\ndef calculate_extras():\n    total = 0\n    if syrup.value == 1:\n        total += 20\n    if sprinkles.value == 1:\n        total += 10\n    if cream.value == 1:\n        total += 50\n    cost.value = total\n\n\napp = App()\n\nquestions = Text(app, text=\"What would you like with your coffee?\")\n\nsyrup = CheckBox(app, text=\"Caramel syrup (20p)\", command=calculate_extras)\nsprinkles = CheckBox(app, text=\"Chocolate sprinkles (10p)\", command=calculate_extras)\ncream = CheckBox(app, text=\"Whipped cream (50p)\", command=calculate_extras)\n\ncost_of_extras = Text(app, text=\"Cost of extras:\")\ncost = TextBox(app, text=\"0\")\n\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/combo/",
            "text": "Combo\n\n\n(Contains a \ntkinter.OptionMenu\n object)\n\n\n__init__(self, master, options, selected=None, command=None, grid=None, align=None)\n\n\nWhat is it?\n\n\nThe \nCombo\n object displays a drop down box allowing a single option to be selected from a list of options.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nCombo\n object like this:\n\n\nfrom guizero import App, Combo\napp = App()\ncombo = Combo(app, options=[\"Beef\", \"Chicken\", \"Fish\", \"Vegetarian\"])\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nCombo\n object you \nmust\n specify \nmaster\n and \noptions\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \ncombo = Combo(app, options=[\"Beef\", \"Chicken\", \"Fish\", \"Vegetarian\"])\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\noptions\n\n\nList\n\n\n-\n\n\nYes\n\n\nA list of options to display\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when a different option is selected. This function MUST take one argument as it will be auto-given the current value of the Combo. \nThe command can only be specified when creating the \nCombo\n object and cannot be changed later.\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nCheckBox\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nadd_option(option)\n\n\noption (string)\n\n\n-\n\n\nAdds a new item to the combo box with the value \noption\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\nclear()\n\n\n-\n\n\n-\n\n\nRemoves all options from the Combo box\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nselect_default()\n\n\n-\n\n\n-\n\n\nResets the combo box so that the first item is selected\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\nget()\n\n\n-\n\n\nstring\n\n\nReplaced by the \nvalue\n property\n\n\n\n\n\n\nset(text)\n\n\ntext (string)\n\n\n-\n\n\nReplaced by the \nvalue\n property\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe text associated with the currently selected option\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nCombo\n object is called \ncombo\n you would write \ncombo.value\n.\n\n\nYou can \nset\n the property (for example \ncombo.value = \"Chicken\"\n) or \nget\n the value of the property to use (for example \nprint(combo.value)\n).\n\n\nExamples\n\n\nCalling a function when the value selected changes\n\n\nYou can call a function when the selected value in a \nCombo\n object changes. This must be set up at the time you create the \nCombo\n object and cannot be defined later. The function you call \nMUST\n take a minimum of one argument as it will automatically be passed a string containing the currently selected value from the \nCombo\n object.\n\n\nfrom guizero import App, Text, Combo\ndef you_chose(selected_value):\n    if selected_value == \"Tiny goblet\":\n        result.value = \"You chose...wisely\"\n    else:\n        result.value = \"You chose...poorly\"\n\napp = App()\ninstructions = Text(app, text=\"Choose a goblet\")\ncombo = Combo(app, options=[\"\", \"Huge golden goblet\", \"Jewel encrusted goblet\", \"Tiny goblet\"], command=you_chose)\nresult = Text(app)\napp.display()",
            "title": "Combo"
        },
        {
            "location": "/combo/#combo",
            "text": "(Contains a  tkinter.OptionMenu  object)  __init__(self, master, options, selected=None, command=None, grid=None, align=None)",
            "title": "Combo"
        },
        {
            "location": "/combo/#what-is-it",
            "text": "The  Combo  object displays a drop down box allowing a single option to be selected from a list of options.",
            "title": "What is it?"
        },
        {
            "location": "/combo/#how-do-i-make-one",
            "text": "Create a  Combo  object like this:  from guizero import App, Combo\napp = App()\ncombo = Combo(app, options=[\"Beef\", \"Chicken\", \"Fish\", \"Vegetarian\"])\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/combo/#starting-parameters",
            "text": "When you create a  Combo  object you  must  specify  master  and  options  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  combo = Combo(app, options=[\"Beef\", \"Chicken\", \"Fish\", \"Vegetarian\"])     Parameter  Takes  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    options  List  -  Yes  A list of options to display    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    command  function name  None  -  The name of a function to call when a different option is selected. This function MUST take one argument as it will be auto-given the current value of the Combo.  The command can only be specified when creating the  Combo  object and cannot be changed later.    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.",
            "title": "Starting parameters"
        },
        {
            "location": "/combo/#methods",
            "text": "You can call the following methods on a  CheckBox  object.     Method  Takes  Returns  Description      add_option(option)  option (string)  -  Adds a new item to the combo box with the value  option    after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    clear()  -  -  Removes all options from the Combo box    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    select_default()  -  -  Resets the combo box so that the first item is selected    show()  -  -  Displays the widget if it was previously hidden    get()  -  string  Replaced by the  value  property    set(text)  text (string)  -  Replaced by the  value  property     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/combo/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      enabled  boolean  True  if the widget is enabled    value  string  The text associated with the currently selected option     Refer to a property as  <name of widget>.property . For example, if your  Combo  object is called  combo  you would write  combo.value .  You can  set  the property (for example  combo.value = \"Chicken\" ) or  get  the value of the property to use (for example  print(combo.value) ).",
            "title": "Properties"
        },
        {
            "location": "/combo/#examples",
            "text": "Calling a function when the value selected changes  You can call a function when the selected value in a  Combo  object changes. This must be set up at the time you create the  Combo  object and cannot be defined later. The function you call  MUST  take a minimum of one argument as it will automatically be passed a string containing the currently selected value from the  Combo  object.  from guizero import App, Text, Combo\ndef you_chose(selected_value):\n    if selected_value == \"Tiny goblet\":\n        result.value = \"You chose...wisely\"\n    else:\n        result.value = \"You chose...poorly\"\n\napp = App()\ninstructions = Text(app, text=\"Choose a goblet\")\ncombo = Combo(app, options=[\"\", \"Huge golden goblet\", \"Jewel encrusted goblet\", \"Tiny goblet\"], command=you_chose)\nresult = Text(app)\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/menubar/",
            "text": "MenuBar\n\n\n(Contains a \ntkinter.Menu\n object)\n\n\n__init__(self, master, toplevel, options)\n\n\nWhat is it?\n\n\nThe \nMenuBar\n object displays a menu at the top of the screen, with each menu option leading to a submenu.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nMenuBar\n object like this:\n\n\nfrom guizero import App, MenuBar\ndef file_function():\n    print(\"File option\")\n\ndef edit_function():\n    print(\"Edit option\")\n\napp = App()\nmenubar = MenuBar(app,\n                  toplevel=[\"File\", \"Edit\"],\n                  options=[\n                      [ [\"File option 1\", file_function], [\"File option 2\", file_function] ],\n                      [ [\"Edit option 1\", edit_function], [\"Edit option 2\", edit_function] ]\n                  ])\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nMenuBar\n object you \nmust\n specify all of the parameters.\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\ntoplevel\n\n\nlist\n\n\n-\n\n\nYes\n\n\nA list of top level menu items\n\n\n\n\n\n\noptions\n\n\n3D list\n\n\n-\n\n\nYes\n\n\nA list of submenus, with each submenu being a list of options and each option being a text/command pair. See notes above for more details.\n\n\n\n\n\n\n\n\nThe \ntoplevel\n parameter should be a list of options you wish to display on the menu. In the example, the \ntoplevel\n options are File and Edit:\n\n\n\n\nThe options parameter should be a 3D List containing lists of submenu items, which are themselves lists. The elements in the list correspond to the elements in the \ntoplevel\n list, so the first list of submenu items provided in \noptions\n will be the submenu for the first menu heading provided in \ntoplevel\n and so on.\n\n\nThe menu item sub-sublists within \noptions\n should contain pairs consisting of the text to display on the menu and the function to call when that option is selected. In this example, the text \"File option 1\" is displayed and the function \nfile_function\n is called if this option is clicked on.\n\n\n[\"File option 1\", file_function]\n\n\n\n\nThe MenuBar is never displayed on a grid so there are no grid or alignment parameters.\n\n\nMethods\n\n\nYou can call the following methods on an \nMenuBar\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\n\n\nProperties\n\n\nThere are no properties for the \nMenuBar\n object",
            "title": "MenuBar"
        },
        {
            "location": "/menubar/#menubar",
            "text": "(Contains a  tkinter.Menu  object)  __init__(self, master, toplevel, options)",
            "title": "MenuBar"
        },
        {
            "location": "/menubar/#what-is-it",
            "text": "The  MenuBar  object displays a menu at the top of the screen, with each menu option leading to a submenu.",
            "title": "What is it?"
        },
        {
            "location": "/menubar/#how-do-i-make-one",
            "text": "Create a  MenuBar  object like this:  from guizero import App, MenuBar\ndef file_function():\n    print(\"File option\")\n\ndef edit_function():\n    print(\"Edit option\")\n\napp = App()\nmenubar = MenuBar(app,\n                  toplevel=[\"File\", \"Edit\"],\n                  options=[\n                      [ [\"File option 1\", file_function], [\"File option 2\", file_function] ],\n                      [ [\"Edit option 1\", edit_function], [\"Edit option 2\", edit_function] ]\n                  ])\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/menubar/#starting-parameters",
            "text": "When you create a  MenuBar  object you  must  specify all of the parameters.     Parameter  Takes  Default  Compulsory  Description      master  App  -  Yes  The container to which this widget belongs    toplevel  list  -  Yes  A list of top level menu items    options  3D list  -  Yes  A list of submenus, with each submenu being a list of options and each option being a text/command pair. See notes above for more details.     The  toplevel  parameter should be a list of options you wish to display on the menu. In the example, the  toplevel  options are File and Edit:   The options parameter should be a 3D List containing lists of submenu items, which are themselves lists. The elements in the list correspond to the elements in the  toplevel  list, so the first list of submenu items provided in  options  will be the submenu for the first menu heading provided in  toplevel  and so on.  The menu item sub-sublists within  options  should contain pairs consisting of the text to display on the menu and the function to call when that option is selected. In this example, the text \"File option 1\" is displayed and the function  file_function  is called if this option is clicked on.  [\"File option 1\", file_function]  The MenuBar is never displayed on a grid so there are no grid or alignment parameters.",
            "title": "Starting parameters"
        },
        {
            "location": "/menubar/#methods",
            "text": "You can call the following methods on an  MenuBar  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.",
            "title": "Methods"
        },
        {
            "location": "/menubar/#properties",
            "text": "There are no properties for the  MenuBar  object",
            "title": "Properties"
        },
        {
            "location": "/picture/",
            "text": "Picture\n\n\n(Contains a \ntkinter.Label\n object)\n\n\n__init__(self, master, image, grid=None, align=None)\n\n\nWhat is it?\n\n\nThe \nPicture\n object displays a GIF image\n\n\n\n\nHow do I make one?\n\n\nCreate a \nPicture\n object like this:\n\n\nfrom guizero import App, Picture\napp = App()\npicture = Picture(app, image=\"test.gif\")\napp.display()\n\n\n\n\nYou must specify the correct path to the image. The image in the example is in the same directory as the program. If the image is in a different directory, specify a relative path, for example if the picture is in a subfolder called \nimages\n you would write:\n\n\npicture = Picture(app, image=\"images/test.gif\")\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nPicture\n object you \nmust\n specify \nmaster\n and \nimage\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \npicture = Picture(app, image=\"test.gif\")\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nimage\n\n\nList\n\n\n-\n\n\nYes\n\n\nThe path to the image file you wish to display\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nPicture\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\nset(image)\n\n\nimage (string)\n\n\n-\n\n\nReplaced by the \nvalue\n property\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe filename of the image\n\n\n\n\n\n\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nPicture\n object is called \npicture\n you would write \npicture.value\n.\n\n\nYou can \nset\n the property (for example \npicture.value = \"star.gif\"\n) or \nget\n the value of the property to use (for example \nprint(picture.value)\n).",
            "title": "Picture"
        },
        {
            "location": "/picture/#picture",
            "text": "(Contains a  tkinter.Label  object)  __init__(self, master, image, grid=None, align=None)",
            "title": "Picture"
        },
        {
            "location": "/picture/#what-is-it",
            "text": "The  Picture  object displays a GIF image",
            "title": "What is it?"
        },
        {
            "location": "/picture/#how-do-i-make-one",
            "text": "Create a  Picture  object like this:  from guizero import App, Picture\napp = App()\npicture = Picture(app, image=\"test.gif\")\napp.display()  You must specify the correct path to the image. The image in the example is in the same directory as the program. If the image is in a different directory, specify a relative path, for example if the picture is in a subfolder called  images  you would write:  picture = Picture(app, image=\"images/test.gif\")",
            "title": "How do I make one?"
        },
        {
            "location": "/picture/#starting-parameters",
            "text": "When you create a  Picture  object you  must  specify  master  and  image  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  picture = Picture(app, image=\"test.gif\")     Parameter  Takes  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    image  List  -  Yes  The path to the image file you wish to display    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.",
            "title": "Starting parameters"
        },
        {
            "location": "/picture/#methods",
            "text": "You can call the following methods on a  Picture  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the widget if it was previously hidden    set(image)  image (string)  -  Replaced by the  value  property     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/picture/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      enabled  boolean  True  if the widget is enabled    value  string  The filename of the image     Refer to a property as  <name of widget>.property . For example, if your  Picture  object is called  picture  you would write  picture.value .  You can  set  the property (for example  picture.value = \"star.gif\" ) or  get  the value of the property to use (for example  print(picture.value) ).",
            "title": "Properties"
        },
        {
            "location": "/pushbutton/",
            "text": "PushButton\n\n\n(Contains a \ntkinter.Button\n object)\n\n\n__init__(self, master, command, args=None, text=\"Button\", icon=None, pady=10, padx=10, grid=None, align=None)\n\n\nWhat is it?\n\n\nThe \nPushButton\n object displays a button with text or an image, which calls a function when pressed.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nPushButton\n object like this:\n\n\nfrom guizero import App, PushButton\ndef do_nothing():\n  print(\"Button was pressed\")\n\napp = App()\nbutton = PushButton(app, command=do_nothing)\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nPushButton\n object you \nmust\n specify \nmaster\n and \ncommand\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \nbutton = PushButton(app, command=do_nothing)\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\n-\n\n\nYes\n\n\nThe name of a function to call when the button is pressed.\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nargs\n\n\nlist\n\n\nNone\n\n\n-\n\n\nIf you wish to pass any arguments to the function specified in the command parameter, you can specify them as a list\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nicon\n\n\nstring\n\n\nNone\n\n\n-\n\n\nThe path to a GIF image file to display on the button. If both an icon and text are specified, the image will override the text.\n\n\n\n\n\n\npadx\n\n\nint\n\n\n10\n\n\n-\n\n\nHow much horizontal padding to add between the text/icon and the edge of the button.\n\n\n\n\n\n\npady\n\n\nint\n\n\n10\n\n\n-\n\n\nHow much vertical padding to add between the text/icon and the edge of the button.\n\n\n\n\n\n\ntext\n\n\nstring\n\n\n\"Button\"\n\n\n-\n\n\nThe text to display on the button\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nPushButton\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\nchange_command(newcommand, args)\n\n\nnewcommand (function name), args (list)\n\n\n-\n\n\nSets the function called when the button is pressed to the one specified as \nnewcommand\n. You can optionally specify new \nargs\n as a list.\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nicon(icon)\n\n\nicon (string)\n\n\n-\n\n\nSets the image displayed on the button to the filename specified. If the image is in a different directory, you must specify the relative path.\n\n\n\n\n\n\npadding(padx, pady)\n\n\npadx (int), pady(int)\n\n\n-\n\n\nSets the amount of x (horizontal) and y (vertical) padding between the text/icon and the edge of the button\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\ntoggle()\n\n\n-\n\n\n-\n\n\nChanges the state of the button to the opposite of its current state - if it is currently enabled, disable it and vice versa.\n\n\n\n\n\n\nset_text(text)\n\n\ntext (string)\n\n\n-\n\n\nReplaced by the \ntext\n property\n\n\n\n\n\n\ntoggle_state()\n\n\n-\n\n\n-\n\n\nRenamed to \ntoggle()\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbg\n\n\nstring\n\n\nThe background colour of the button\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text on the button\n\n\n\n\n\n\nheight\n\n\nint\n\n\nThe height of the button\n\n\n\n\n\n\ntext\n\n\nstring\n\n\nThe text on the button\n\n\n\n\n\n\ntext_color\n\n\nstring\n\n\nThe colour of the text on the button\n\n\n\n\n\n\ntext_size\n\n\nint\n\n\nThe size of the text on the button\n\n\n\n\n\n\nvalue\n\n\nint\n\n\nReturns 1 when the button is pressed, 0 if the button is released\n\n\n\n\n\n\nwidth\n\n\nint\n\n\nThe width of the button\n\n\n\n\n\n\n\n\nNOTE:\n The height and width are currently measured in 'characters' so if you change the font size, this will change the size of the button. \nThis may change in a future version of guizero.\n\n\nRefer to a property as \n<name of widget>.property\n. For example, if your \nPushButton\n object is called \nbutton\n you would write \nbutton.value\n.\n\n\nYou can \nset\n the property (for example \nbutton.bg = \"red\"\n) or \nget\n the value of the property to use (for example \nprint(button.bg)\n).",
            "title": "PushButton"
        },
        {
            "location": "/pushbutton/#pushbutton",
            "text": "(Contains a  tkinter.Button  object)  __init__(self, master, command, args=None, text=\"Button\", icon=None, pady=10, padx=10, grid=None, align=None)",
            "title": "PushButton"
        },
        {
            "location": "/pushbutton/#what-is-it",
            "text": "The  PushButton  object displays a button with text or an image, which calls a function when pressed.",
            "title": "What is it?"
        },
        {
            "location": "/pushbutton/#how-do-i-make-one",
            "text": "Create a  PushButton  object like this:  from guizero import App, PushButton\ndef do_nothing():\n  print(\"Button was pressed\")\n\napp = App()\nbutton = PushButton(app, command=do_nothing)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/pushbutton/#starting-parameters",
            "text": "When you create a  PushButton  object you  must  specify  master  and  command  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  button = PushButton(app, command=do_nothing)     Parameter  Takes  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    command  function name  -  Yes  The name of a function to call when the button is pressed.    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    args  list  None  -  If you wish to pass any arguments to the function specified in the command parameter, you can specify them as a list    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    icon  string  None  -  The path to a GIF image file to display on the button. If both an icon and text are specified, the image will override the text.    padx  int  10  -  How much horizontal padding to add between the text/icon and the edge of the button.    pady  int  10  -  How much vertical padding to add between the text/icon and the edge of the button.    text  string  \"Button\"  -  The text to display on the button",
            "title": "Starting parameters"
        },
        {
            "location": "/pushbutton/#methods",
            "text": "You can call the following methods on a  PushButton  object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    change_command(newcommand, args)  newcommand (function name), args (list)  -  Sets the function called when the button is pressed to the one specified as  newcommand . You can optionally specify new  args  as a list.    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    icon(icon)  icon (string)  -  Sets the image displayed on the button to the filename specified. If the image is in a different directory, you must specify the relative path.    padding(padx, pady)  padx (int), pady(int)  -  Sets the amount of x (horizontal) and y (vertical) padding between the text/icon and the edge of the button    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the widget if it was previously hidden    toggle()  -  -  Changes the state of the button to the opposite of its current state - if it is currently enabled, disable it and vice versa.    set_text(text)  text (string)  -  Replaced by the  text  property    toggle_state()  -  -  Renamed to  toggle()     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/pushbutton/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      bg  string  The background colour of the button    enabled  boolean  True  if the widget is enabled    font  string  The font of the text on the button    height  int  The height of the button    text  string  The text on the button    text_color  string  The colour of the text on the button    text_size  int  The size of the text on the button    value  int  Returns 1 when the button is pressed, 0 if the button is released    width  int  The width of the button     NOTE:  The height and width are currently measured in 'characters' so if you change the font size, this will change the size of the button.  This may change in a future version of guizero.  Refer to a property as  <name of widget>.property . For example, if your  PushButton  object is called  button  you would write  button.value .  You can  set  the property (for example  button.bg = \"red\" ) or  get  the value of the property to use (for example  print(button.bg) ).",
            "title": "Properties"
        },
        {
            "location": "/slider/",
            "text": "Slider\n\n\n(Contains a \ntkinter.Scale\n object)\n\n\n__init__(self, master, start=0, end=100, horizontal=True, command=None, grid=None, align=None)\n\n\nWhat is it?\n\n\nThe \nSlider\n object displays a bar and selector which can be used to specify a value in a range.\n\n\nThe above code looks like this on Windows:\n\n\n\nHow do I make one?\n\n\nCreate a \nSlider\n object like this:\n\n\nfrom guizero import App, Slider\napp = App()\nslider = Slider(app)\napp.display()\n\n\n\n\nStarting paramters\n\n\nWhen you create a \nSlider\n object, you \nmust\n specify a \nmaster\n and you can specify any of the the optional parameters. Specify parameters in the brackets, like this: \nslider = Slider(app, horizontal=False)\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ncommand\n\n\nfunction name\n\n\nNone\n\n\n-\n\n\nThe name of a function to call when the slider value is changed\n\n\n\n\n\n\nend\n\n\nint\n\n\n100\n\n\n-\n\n\nThe largest value selectable on the slider\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nhorizontal\n\n\nBoolean\n\n\nTrue\n\n\n-\n\n\nWhether you wish to display your slider horizontally or vertically (defaults to horizontal)\n\n\n\n\n\n\nstart\n\n\nint\n\n\n0\n\n\n-\n\n\nThe smallest value selectable on the slider\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nSlider\n object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nadd_command(command)\n\n\ncommand (function name)\n\n\n-\n\n\nSets the function called when the slider value is changed to the function specified in \ncommand\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe current value of the slider\n\n\n\n\n\n\n\n\nExamples\n\n\nCalling a function when the slider value changes\n\n\nYou can specify a function to call when the slider value changes. Your function \nMUST\n have a minimum of one parameter as it will automatically receive a string containing the value of the slider (called \nslider_value\n in the example) when it is called.\n\n\nThis code has a slider and a text box, and the text box updates automatically to display the current value of the slider.\n\n\n\n\nfrom guizero import App, Slider, TextBox\ndef slider_changed(slider_value):\n    textbox.value = slider_value\n\napp = App()\nslider = Slider(app, command=slider_changed)\ntextbox = TextBox(app)\napp.display()",
            "title": "Slider"
        },
        {
            "location": "/slider/#slider",
            "text": "(Contains a  tkinter.Scale  object)  __init__(self, master, start=0, end=100, horizontal=True, command=None, grid=None, align=None)",
            "title": "Slider"
        },
        {
            "location": "/slider/#what-is-it",
            "text": "The  Slider  object displays a bar and selector which can be used to specify a value in a range.  The above code looks like this on Windows:",
            "title": "What is it?"
        },
        {
            "location": "/slider/#how-do-i-make-one",
            "text": "Create a  Slider  object like this:  from guizero import App, Slider\napp = App()\nslider = Slider(app)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/slider/#starting-paramters",
            "text": "When you create a  Slider  object, you  must  specify a  master  and you can specify any of the the optional parameters. Specify parameters in the brackets, like this:  slider = Slider(app, horizontal=False)     Parameter  Takes  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    command  function name  None  -  The name of a function to call when the slider value is changed    end  int  100  -  The largest value selectable on the slider    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    horizontal  Boolean  True  -  Whether you wish to display your slider horizontally or vertically (defaults to horizontal)    start  int  0  -  The smallest value selectable on the slider",
            "title": "Starting paramters"
        },
        {
            "location": "/slider/#methods",
            "text": "You can call the following methods on a  Slider  object.     Method  Takes  Returns  Description      add_command(command)  command (function name)  -  Sets the function called when the slider value is changed to the function specified in  command    after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the widget if it was previously hidden",
            "title": "Methods"
        },
        {
            "location": "/slider/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      enabled  boolean  True  if the widget is enabled    value  string  The current value of the slider",
            "title": "Properties"
        },
        {
            "location": "/slider/#examples",
            "text": "Calling a function when the slider value changes  You can specify a function to call when the slider value changes. Your function  MUST  have a minimum of one parameter as it will automatically receive a string containing the value of the slider (called  slider_value  in the example) when it is called.  This code has a slider and a text box, and the text box updates automatically to display the current value of the slider.   from guizero import App, Slider, TextBox\ndef slider_changed(slider_value):\n    textbox.value = slider_value\n\napp = App()\nslider = Slider(app, command=slider_changed)\ntextbox = TextBox(app)\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/text/",
            "text": "Text\n\n\n(Contains a \ntkinter.Label\n object)\n\n\n__init__(self, master, text=\"\", size=12, color=\"black\", text_color=None, bg=None, font=\"Helvetica\", grid=None, align=None)\n\n\nWhat is it?\n\n\nThe \nText\n object displays non editable text in your app, useful for titles, labels and instructions.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nText\n object like this:\n\n\nfrom guizero import App, Text\napp = App()\ntext = Text(app, text=\"Hello World\")\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nText\n object, you \nmust\n specify a \nmaster\n and you can specify any of the the optional parameters. Specify parameters in the brackets, like this: \ntext = Text(app, text=\"hi\")\n\n\n\n\n\n\n\n\nParameter\n\n\nData type\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ncolor\n\n\nstring\n\n\nblack\n\n\n-\n\n\nThe colour of the text. Accepts some colour strings (e.g. \nred\n) and colours specified in hex format (e.g. \n#0099ff\n)\n\n\n\n\n\n\nfont\n\n\nstring\n\n\n\"Helvetica\"\n\n\n-\n\n\nThe font face that the text will be displayed in. Availability of fonts depends on which fonts are installed locally.\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nsize\n\n\nint\n\n\n12\n\n\n-\n\n\nThe font size of the text\n\n\n\n\n\n\ntext\n\n\nstring\n\n\n\"\"\n\n\n-\n\n\nThe text you want to display\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on a \nText\n object..\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\nappend(text)\n\n\ntext (string)\n\n\n-\n\n\nAdds the provided \ntext\n to the end of the current text within the object\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\nclear()\n\n\n-\n\n\n-\n\n\nClears the text\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\ncolor(color)\n\n\ncolor (string)\n\n\n-\n\n\nReplaced by \ntext_color\n property\n\n\n\n\n\n\nfont_face(font)\n\n\nfont (string)\n\n\n-\n\n\nReplaced by \nfont\n property\n\n\n\n\n\n\nfont_size(size)\n\n\nsize (int)\n\n\n-\n\n\nReplaced by \nsize\n property\n\n\n\n\n\n\nget()\n\n\n-\n\n\nstring\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\nset(text)\n\n\ntext (string)\n\n\n-\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbg\n\n\nstring\n\n\nThe background colour\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nfont\n\n\nstring\n\n\nThe font of the text\n\n\n\n\n\n\nsize\n\n\nint\n\n\nThe size of the text\n\n\n\n\n\n\ntext_color\n\n\nstring\n\n\nThe colour of the text\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe text",
            "title": "Text"
        },
        {
            "location": "/text/#text",
            "text": "(Contains a  tkinter.Label  object)  __init__(self, master, text=\"\", size=12, color=\"black\", text_color=None, bg=None, font=\"Helvetica\", grid=None, align=None)",
            "title": "Text"
        },
        {
            "location": "/text/#what-is-it",
            "text": "The  Text  object displays non editable text in your app, useful for titles, labels and instructions.",
            "title": "What is it?"
        },
        {
            "location": "/text/#how-do-i-make-one",
            "text": "Create a  Text  object like this:  from guizero import App, Text\napp = App()\ntext = Text(app, text=\"Hello World\")\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/text/#starting-parameters",
            "text": "When you create a  Text  object, you  must  specify a  master  and you can specify any of the the optional parameters. Specify parameters in the brackets, like this:  text = Text(app, text=\"hi\")     Parameter  Data type  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    color  string  black  -  The colour of the text. Accepts some colour strings (e.g.  red ) and colours specified in hex format (e.g.  #0099ff )    font  string  \"Helvetica\"  -  The font face that the text will be displayed in. Availability of fonts depends on which fonts are installed locally.    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    size  int  12  -  The font size of the text    text  string  \"\"  -  The text you want to display",
            "title": "Starting parameters"
        },
        {
            "location": "/text/#methods",
            "text": "You can call the following methods on a  Text  object..     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    append(text)  text (string)  -  Adds the provided  text  to the end of the current text within the object    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    clear()  -  -  Clears the text    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the widget if it was previously hidden    color(color)  color (string)  -  Replaced by  text_color  property    font_face(font)  font (string)  -  Replaced by  font  property    font_size(size)  size (int)  -  Replaced by  size  property    get()  -  string  Replaced by  value  property    set(text)  text (string)  -  Replaced by  value  property     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/text/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      bg  string  The background colour    enabled  boolean  True  if the widget is enabled    font  string  The font of the text    size  int  The size of the text    text_color  string  The colour of the text    value  string  The text",
            "title": "Properties"
        },
        {
            "location": "/textbox/",
            "text": "TextBox\n\n\n(Contains a \ntkinter.Entry\n object)\n\n\n__init__(self, master, text=\"\", width=10, grid=None, align=None)\n\n\nWhat is it\n\n\nThe \nTextBox\n object sisplay a text box which the user can type in.\n\n\n\n\nHow do I make one?\n\n\nCreate a \nTextBox\n object like this:\n\n\nfrom guizero import App, TextBox\napp = App()\ninput_box = TextBox(app)\napp.display()\n\n\n\n\nStarting parameters\n\n\nWhen you create a \nTextBox\n object you \nmust\n specify \nmaster\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \ntextbox = TextBox(app, text=\"Please enter some text\")\n\n\n\n\n\n\n\n\nParameter\n\n\nData type\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ntext\n\n\nstring\n\n\n\"\"\n\n\n-\n\n\nAny text you wish to be pre-filled in the text box\n\n\n\n\n\n\nwidth\n\n\nint\n\n\n10\n\n\n-\n\n\nThe width of the text box\n\n\n\n\n\n\n\n\nMethods\n\n\nYou can call the following methods on your TextBox object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\nappend(text)\n\n\ntext (string)\n\n\n-\n\n\nAdds the provided \ntext\n to the end of the current text within the text box\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\nclear()\n\n\n-\n\n\n-\n\n\nClears the textbox\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\ndisable()\n\n\n-\n\n\n-\n\n\nDisables the widget so that it is \"greyed out\" and cannot be interacted with\n\n\n\n\n\n\nenable()\n\n\n-\n\n\n-\n\n\nEnables the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget if it was previously hidden\n\n\n\n\n\n\nget()\n\n\n-\n\n\nstring\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\nset(text)\n\n\ntext (string)\n\n\n-\n\n\nReplaced by \nvalue\n property\n\n\n\n\n\n\n\n\nMethods in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nenabled\n\n\nboolean\n\n\nTrue\n if the widget is enabled\n\n\n\n\n\n\nvalue\n\n\nstring\n\n\nThe text in the TextBox\n\n\n\n\n\n\n\n\nExamples\n\n\nCreating a TextBox with default text\n\n\nYou can set the default text in a TextBox when it is created using the \ntext\n parameter:\n\n\nfrom guizero import App, TextBox\napp = App()\ninput_box = TextBox(app, text=\"Type here\")\napp.display()",
            "title": "TextBox"
        },
        {
            "location": "/textbox/#textbox",
            "text": "(Contains a  tkinter.Entry  object)  __init__(self, master, text=\"\", width=10, grid=None, align=None)",
            "title": "TextBox"
        },
        {
            "location": "/textbox/#what-is-it",
            "text": "The  TextBox  object sisplay a text box which the user can type in.",
            "title": "What is it"
        },
        {
            "location": "/textbox/#how-do-i-make-one",
            "text": "Create a  TextBox  object like this:  from guizero import App, TextBox\napp = App()\ninput_box = TextBox(app)\napp.display()",
            "title": "How do I make one?"
        },
        {
            "location": "/textbox/#starting-parameters",
            "text": "When you create a  TextBox  object you  must  specify  master  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  textbox = TextBox(app, text=\"Please enter some text\")     Parameter  Data type  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    text  string  \"\"  -  Any text you wish to be pre-filled in the text box    width  int  10  -  The width of the text box",
            "title": "Starting parameters"
        },
        {
            "location": "/textbox/#methods",
            "text": "You can call the following methods on your TextBox object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    append(text)  text (string)  -  Adds the provided  text  to the end of the current text within the text box    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    clear()  -  -  Clears the textbox    destroy()  -  -  Destroys the widget    disable()  -  -  Disables the widget so that it is \"greyed out\" and cannot be interacted with    enable()  -  -  Enables the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    show()  -  -  Displays the widget if it was previously hidden    get()  -  string  Replaced by  value  property    set(text)  text (string)  -  Replaced by  value  property     Methods in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "Methods"
        },
        {
            "location": "/textbox/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      enabled  boolean  True  if the widget is enabled    value  string  The text in the TextBox",
            "title": "Properties"
        },
        {
            "location": "/textbox/#examples",
            "text": "Creating a TextBox with default text  You can set the default text in a TextBox when it is created using the  text  parameter:  from guizero import App, TextBox\napp = App()\ninput_box = TextBox(app, text=\"Type here\")\napp.display()",
            "title": "Examples"
        },
        {
            "location": "/waffle/",
            "text": "Waffle\n\n\n(Contains a \ntkinter.Frame\n object)\n\n\n__init__(self, master, height=3, width=3, dim=20, pad=5, color=\"white\", dotty=False, grid=None, align=None, command=None)\n\n\nWhat is it\n\n\nThe \nWaffle\n object display an n*n grid of squares with custom dimensions and padding\n\n\n\n\nHow do I make one?\n\n\nCreate a \nWaffle\n object like this:\n\n\nfrom guizero import App, Waffle\napp = App()\nwaffle = Waffle(app)\napp.display()\n\n\n\n\nWhen you create a \nWaffle\n object you \nmust\n specify \nmaster\n and you can specify any of the optional parameters. Specify parameters in the brackets, like this: \nwaffle = Waffle(app, height=25)\n\n\n\n\n\n\n\n\nParameter\n\n\nTakes\n\n\nDefault\n\n\nCompulsory\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmaster\n\n\nApp or Box\n\n\n-\n\n\nYes\n\n\nThe container to which this widget belongs\n\n\n\n\n\n\nalign\n\n\nstring\n\n\nNone\n\n\n-\n\n\nAlignment of this widget within its grid location. Possible values: \n\"top\"\n, \n\"bottom\"\n, \n\"left\"\n, \n\"right\"\n. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\ncolor\n\n\nstring\n\n\n\"white\"\n\n\n-\n\n\nThe starting colour of all pixels on the waffle\n\n\n\n\n\n\ndim\n\n\nint\n\n\n20\n\n\n-\n\n\nHow large one of the pixels on the waffle is\n\n\n\n\n\n\ndotty\n\n\nboolean\n\n\nFalse\n\n\n-\n\n\nWhether the pixels display as dots/circles (True) or squares (False)\n\n\n\n\n\n\ngrid\n\n\nList [int, int]\n\n\nNone\n\n\n-\n\n\n[x,y]\n coordinates of this widget. This parameter is only required if the \nmaster\n object has a grid layout.\n\n\n\n\n\n\nheight\n\n\nint\n\n\n3\n\n\n-\n\n\nHow many pixels high the waffle is\n\n\n\n\n\n\npad\n\n\nint\n\n\n5\n\n\n-\n\n\nHow much space is between the pixels on the waffle\n\n\n\n\n\n\nwidth\n\n\nint\n\n\n3\n\n\n-\n\n\nHow many pixels wide the waffle is\n\n\n\n\n\n\nremember\n\n\nboolean\n\n\nTrue\n\n\n-\n\n\nNo longer needed - all Waffles will now have a memory.\n\n\n\n\n\n\n\n\nParameters in \nitalics\n will still work but are \ndeprecated\n - this means you should stop using them because they may not work in future versions of guizero\n\n\nMethods\n\n\nYou can call the following methods on your Waffle object.\n\n\n\n\n\n\n\n\nMethod\n\n\nTakes\n\n\nReturns\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nafter(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nSchedules a \nsingle\n call to \ncommand\n after \ntime\n milliseconds. (To repeatedly call the same command, use \nrepeat()\n)\n\n\n\n\n\n\ncancel(command)\n\n\ncommand (function name)\n\n\n-\n\n\nCancels a scheduled call to \ncommand\n\n\n\n\n\n\ndestroy()\n\n\n-\n\n\n-\n\n\nDestroys the widget\n\n\n\n\n\n\nfocus()\n\n\n-\n\n\n-\n\n\nGives focus to the widget (e.g. focusing a \nTextBox\n so that the user can type inside it)\n\n\n\n\n\n\nget_all()\n\n\n-\n\n\nList\n\n\nIMPORTANT: To use this function, you must set remember=True when you create the Waffle. Returns the pixel colours in the grid as a 2D list.\n\n\n\n\n\n\nget_pixel(x, y)\n\n\nx (int), y (int)\n\n\nstring\n\n\nIMPORTANT: To use this function, you must set remember=True when you create the Waffle. Returns the colour of the pixel at the specified coordinates. 0,0 is the top left of the grid.\n\n\n\n\n\n\nhide()\n\n\n-\n\n\n-\n\n\nHides the widget from view. This method will unpack the widget from the layout manager.\n\n\n\n\n\n\nrepeat(time, command)\n\n\ntime (int), command (function name)\n\n\n-\n\n\nRepeats \ncommand\n every \ntime\n milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.\n\n\n\n\n\n\nset_all(color)\n\n\ncolor (string)\n\n\n-\n\n\nSets all pixels to the specified colour (allows hex code e.g. #0099ff or colour name e.g. \"red\")\n\n\n\n\n\n\nset_pixel(x, y, color)\n\n\nx (int), y (int), color (string)\n\n\n-\n\n\nSets the pixel at the specified coordinates to the specified colour. 0,0 is the top left of the grid.\n\n\n\n\n\n\nshow()\n\n\n-\n\n\n-\n\n\nDisplays the widget\n\n\n\n\n\n\n\n\nProperties\n\n\nYou can set and get the following properties:\n\n\n\n\n\n\n\n\nMethod\n\n\nData type\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncolor\n\n\nint\n\n\nThe color of the whole waffle\n\n\n\n\n\n\ndotty\n\n\nbool\n\n\nIf \nTrue\n the waffle will display circles\n\n\n\n\n\n\nheight\n\n\nint\n\n\nThe height of the waffle\n\n\n\n\n\n\npad\n\n\nint\n\n\nThe size of the padding between pixels\n\n\n\n\n\n\npixel_size\n\n\nint\n\n\nThe size of the one pixel\n\n\n\n\n\n\nwidth\n\n\nint\n\n\nThe width of the waffle\n\n\n\n\n\n\n\n\nExample\n\n\nSet a pixel colour\n\n\nA Waffle can remember the colour of each pixel within it.\n\n\nfrom guizero import App, Waffle\n\napp = App()\n\nmy_waffle = Waffle(app)\nmy_waffle.set_pixel(2, 1, \"red\")\n\n# Your waffle will remember what colour each pixel is\nprint(my_waffle.get_pixel(2,1))\n\n# Even the ones auto-set at the start (which are white by default)\nprint(my_waffle.get_pixel(1,1))\n\napp.display()",
            "title": "Waffle"
        },
        {
            "location": "/waffle/#waffle",
            "text": "(Contains a  tkinter.Frame  object)  __init__(self, master, height=3, width=3, dim=20, pad=5, color=\"white\", dotty=False, grid=None, align=None, command=None)",
            "title": "Waffle"
        },
        {
            "location": "/waffle/#what-is-it",
            "text": "The  Waffle  object display an n*n grid of squares with custom dimensions and padding",
            "title": "What is it"
        },
        {
            "location": "/waffle/#how-do-i-make-one",
            "text": "Create a  Waffle  object like this:  from guizero import App, Waffle\napp = App()\nwaffle = Waffle(app)\napp.display()  When you create a  Waffle  object you  must  specify  master  and you can specify any of the optional parameters. Specify parameters in the brackets, like this:  waffle = Waffle(app, height=25)     Parameter  Takes  Default  Compulsory  Description      master  App or Box  -  Yes  The container to which this widget belongs    align  string  None  -  Alignment of this widget within its grid location. Possible values:  \"top\" ,  \"bottom\" ,  \"left\" ,  \"right\" . This parameter is only required if the  master  object has a grid layout.    color  string  \"white\"  -  The starting colour of all pixels on the waffle    dim  int  20  -  How large one of the pixels on the waffle is    dotty  boolean  False  -  Whether the pixels display as dots/circles (True) or squares (False)    grid  List [int, int]  None  -  [x,y]  coordinates of this widget. This parameter is only required if the  master  object has a grid layout.    height  int  3  -  How many pixels high the waffle is    pad  int  5  -  How much space is between the pixels on the waffle    width  int  3  -  How many pixels wide the waffle is    remember  boolean  True  -  No longer needed - all Waffles will now have a memory.     Parameters in  italics  will still work but are  deprecated  - this means you should stop using them because they may not work in future versions of guizero",
            "title": "How do I make one?"
        },
        {
            "location": "/waffle/#methods",
            "text": "You can call the following methods on your Waffle object.     Method  Takes  Returns  Description      after(time, command)  time (int), command (function name)  -  Schedules a  single  call to  command  after  time  milliseconds. (To repeatedly call the same command, use  repeat() )    cancel(command)  command (function name)  -  Cancels a scheduled call to  command    destroy()  -  -  Destroys the widget    focus()  -  -  Gives focus to the widget (e.g. focusing a  TextBox  so that the user can type inside it)    get_all()  -  List  IMPORTANT: To use this function, you must set remember=True when you create the Waffle. Returns the pixel colours in the grid as a 2D list.    get_pixel(x, y)  x (int), y (int)  string  IMPORTANT: To use this function, you must set remember=True when you create the Waffle. Returns the colour of the pixel at the specified coordinates. 0,0 is the top left of the grid.    hide()  -  -  Hides the widget from view. This method will unpack the widget from the layout manager.    repeat(time, command)  time (int), command (function name)  -  Repeats  command  every  time  milliseconds. This is useful for scheduling a function to be regularly called, for example updating a value read from a sensor.    set_all(color)  color (string)  -  Sets all pixels to the specified colour (allows hex code e.g. #0099ff or colour name e.g. \"red\")    set_pixel(x, y, color)  x (int), y (int), color (string)  -  Sets the pixel at the specified coordinates to the specified colour. 0,0 is the top left of the grid.    show()  -  -  Displays the widget",
            "title": "Methods"
        },
        {
            "location": "/waffle/#properties",
            "text": "You can set and get the following properties:     Method  Data type  Description      color  int  The color of the whole waffle    dotty  bool  If  True  the waffle will display circles    height  int  The height of the waffle    pad  int  The size of the padding between pixels    pixel_size  int  The size of the one pixel    width  int  The width of the waffle",
            "title": "Properties"
        },
        {
            "location": "/waffle/#example",
            "text": "Set a pixel colour  A Waffle can remember the colour of each pixel within it.  from guizero import App, Waffle\n\napp = App()\n\nmy_waffle = Waffle(app)\nmy_waffle.set_pixel(2, 1, \"red\")\n\n# Your waffle will remember what colour each pixel is\nprint(my_waffle.get_pixel(2,1))\n\n# Even the ones auto-set at the start (which are white by default)\nprint(my_waffle.get_pixel(1,1))\n\napp.display()",
            "title": "Example"
        },
        {
            "location": "/changelog/",
            "text": "guizero\n\n\n0.4.1 - 2017-12-28\n\n\nBug fixes and deployment test\n\n\n\n\nPushButton bug fixes\n\n\nadded \nenabled\n property to widgets which support \nEnable\n / \nDisable\n\n\ndocumentation tidy up\n\n\nadded build notes to documentation\n\n\n\n\n0.4 - 2017-12-19\n\n\nThank you to everyone who has taken time to contribute code, suggest helpful improvements and report their use of the library. I am extremely grateful to the following people who have contributed pull requests since the last version:\n\nbcroston\n, \nbennuttall\n, \nCoal0\n,  \nmartinohanlon\n and  \nscotty3785\n\n\nI am also very pleased to announce that \nmartinohanlon\n has very kindly agreed to maintain guizero whilst I am on maternity leave, beginning December 2017.\n\n\nGeneral changes:\n\n\n\n\nAll classes rewritten with internal Tk objects rather than extending the Tk object, meaning you can access all Tk functionality as \nObject.tk.tkmethod()\n (Credit for idea: \nbennuttall\n)\n\n\nImproved use of library with tab complete editors (e.g. ipython) \u2013 only the guizero properties and methods are listed so the list is shorter and more friendly. (Credit for idea: \nbennuttall\n)\n\n\n[Bug fix] Grid layout now lays items out properly. Previously the x and y axes were flipped. (Whoops!) \nThis fix will cause apps with a grid layout to look different, but now behave correctly. You may need to update old code as a result of this change.\n\n\nAll classes now inherit from mixins, adding 9 new common methods usable on most widgets - \nafter()\n, \ncancel()\n, \ndestroy()\n, \ndisable()\n, \nenable()\n, \nfocus()\n, \nhide()\n, \nshow()\n, \nrepeat()\n,  (Credit: \nCoal0\n and \nmartinohanlon\n)\n\n\nThe new \nrepeat()\n method allows you to easily specify a repeated callback to a function, making it extremely easy to perform repetitive actions such as updating the GUI based on readings from a sensor.\n\n\nDocumentation and examples have been improved and updated\n\n\n\n\nApp:\n\n\n\n\nNew constructor argument \nbg\n replaces deprecated \nbgcolor\n argument. If both are specified, \nbg\n overrides \nbgcolor\n.\n\n\nset_title()\n and \nbgcolor()\n methods are now deprecated and have been replaced by \ntitle\n and \nbg\n properties\n\n\nNew additional properties \nwidth\n and \nheight\n\n\n\n\nButtonGroup:\n\n\n\n\nget()\n and \nset()\n methods are now deprecated and have been replaced by the \nvalue\n property\n\n\nNew \nvalue_text\n property to get the text associated with the selected option\n\n\n\n\nCheckBox:\n\n\n\n\nget_text()\n, \nget_value()\n and \nchange_text()\n methods are now deprecated and have been replaced by the \nvalue\n and \ntext\n properties\n\n\nNew \ntoggle()\n method added\n\n\n\n\nCombo:\n\n\n\n\nget()\n and \nset()\n methods are now deprecated and have been replaced by the \nvalue\n property\n\n\n[Bug fix] \nset_default()\n now correctly resets the combo back to its originally specified value, whether this was the first option or a specified option\n\n\n\n\nPicture:\n\n\n\n\nset()\n method is now deprecated and has been replaced by the \nvalue\n property\n\n\n\n\nPushButton:\n\n\n\n\nset_text()\n method is now deprecated and has been replaced by the \ntext\n property\n\n\nNew properties for \ntext_color\n, \nbg\n, \nfont\n, \ntext_size\n, \nheight\n and \nwidth\n \u2013 make your buttons look pretty!\n\n\nFind out whether a button is pressed (1) or released (0) with the new \nvalue\n property\n\n\nNew \nicon()\n method to set the icon of a button after it is created\n\n\ntoggle_state()\n method deprecated and renamed to \ntoggle()\n for consistency\n\n\n\n\nSlider:\n\n\n\n\nNew \nvalue\n property for getting and setting the value of the slider\n\n\n\n\nText:\n\n\n\n\nNew constructor arguments \ntext_color\n and \nbg\n\n\ncolor\n constructor argument now deprecated and replaced by \ntext_color\n. If both are specified, \ntext_color\n overrides \ncolor\n.\n\n\nget()\n, \nset()\n, \ncolor()\n, \nfont_face()\n and \nfont_size()\n methods are now deprecated, replaced by properties \nvalue\n, \ntext_color\n, \nbg\n, \nfont\n and \nsize\n\n\n\n\nTextBox:\n\n\n\n\nget()\n and \nset()\n methods now deprecated and replaced by \nvalue\n property\n\n\n\n\nWaffle:\n\n\n\n\nAll waffles will now have a memory. The \nremember\n constructor argument remains for backwards compatibility only \nand will be removed in a future release\n.\n\n\nYou can now click on a Waffle, and specify a command to run when the Waffle is clicked on. The function given as the command should take two arguments as it will be passed the x, y coordinates of the pixel that was clicked. (Credit: \nscotty3785\n)\n\n\nChanged internal implementation of the Waffle so it should now be able to redraw more efficiently. (Credit: \nscotty3785\n)",
            "title": "Change log"
        },
        {
            "location": "/changelog/#guizero",
            "text": "",
            "title": "guizero"
        },
        {
            "location": "/changelog/#041-2017-12-28",
            "text": "Bug fixes and deployment test   PushButton bug fixes  added  enabled  property to widgets which support  Enable  /  Disable  documentation tidy up  added build notes to documentation",
            "title": "0.4.1 - 2017-12-28"
        },
        {
            "location": "/changelog/#04-2017-12-19",
            "text": "Thank you to everyone who has taken time to contribute code, suggest helpful improvements and report their use of the library. I am extremely grateful to the following people who have contributed pull requests since the last version: bcroston ,  bennuttall ,  Coal0 ,   martinohanlon  and   scotty3785  I am also very pleased to announce that  martinohanlon  has very kindly agreed to maintain guizero whilst I am on maternity leave, beginning December 2017.  General changes:   All classes rewritten with internal Tk objects rather than extending the Tk object, meaning you can access all Tk functionality as  Object.tk.tkmethod()  (Credit for idea:  bennuttall )  Improved use of library with tab complete editors (e.g. ipython) \u2013 only the guizero properties and methods are listed so the list is shorter and more friendly. (Credit for idea:  bennuttall )  [Bug fix] Grid layout now lays items out properly. Previously the x and y axes were flipped. (Whoops!)  This fix will cause apps with a grid layout to look different, but now behave correctly. You may need to update old code as a result of this change.  All classes now inherit from mixins, adding 9 new common methods usable on most widgets -  after() ,  cancel() ,  destroy() ,  disable() ,  enable() ,  focus() ,  hide() ,  show() ,  repeat() ,  (Credit:  Coal0  and  martinohanlon )  The new  repeat()  method allows you to easily specify a repeated callback to a function, making it extremely easy to perform repetitive actions such as updating the GUI based on readings from a sensor.  Documentation and examples have been improved and updated   App:   New constructor argument  bg  replaces deprecated  bgcolor  argument. If both are specified,  bg  overrides  bgcolor .  set_title()  and  bgcolor()  methods are now deprecated and have been replaced by  title  and  bg  properties  New additional properties  width  and  height   ButtonGroup:   get()  and  set()  methods are now deprecated and have been replaced by the  value  property  New  value_text  property to get the text associated with the selected option   CheckBox:   get_text() ,  get_value()  and  change_text()  methods are now deprecated and have been replaced by the  value  and  text  properties  New  toggle()  method added   Combo:   get()  and  set()  methods are now deprecated and have been replaced by the  value  property  [Bug fix]  set_default()  now correctly resets the combo back to its originally specified value, whether this was the first option or a specified option   Picture:   set()  method is now deprecated and has been replaced by the  value  property   PushButton:   set_text()  method is now deprecated and has been replaced by the  text  property  New properties for  text_color ,  bg ,  font ,  text_size ,  height  and  width  \u2013 make your buttons look pretty!  Find out whether a button is pressed (1) or released (0) with the new  value  property  New  icon()  method to set the icon of a button after it is created  toggle_state()  method deprecated and renamed to  toggle()  for consistency   Slider:   New  value  property for getting and setting the value of the slider   Text:   New constructor arguments  text_color  and  bg  color  constructor argument now deprecated and replaced by  text_color . If both are specified,  text_color  overrides  color .  get() ,  set() ,  color() ,  font_face()  and  font_size()  methods are now deprecated, replaced by properties  value ,  text_color ,  bg ,  font  and  size   TextBox:   get()  and  set()  methods now deprecated and replaced by  value  property   Waffle:   All waffles will now have a memory. The  remember  constructor argument remains for backwards compatibility only  and will be removed in a future release .  You can now click on a Waffle, and specify a command to run when the Waffle is clicked on. The function given as the command should take two arguments as it will be passed the x, y coordinates of the pixel that was clicked. (Credit:  scotty3785 )  Changed internal implementation of the Waffle so it should now be able to redraw more efficiently. (Credit:  scotty3785 )",
            "title": "0.4 - 2017-12-19"
        }
    ]
}